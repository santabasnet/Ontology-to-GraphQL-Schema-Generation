#----------------------------------*** Schema Definition Started ***----------------------------------

# ----------------------------------------
# Author: Santa Basnet
# Company: Integrated ICT.
# Date: Fri Sep 10 01:33:13 NPT 2021
# ----------------------------------------

#----------------------------------*** Enumeration Types Section ***----------------------------------

enum NarrativeStatus {
    Generated
	Extensions
	Additional
	Empty
}

enum AddressUse {
    Home
	Work
	Temp
	Old
	Billing
}

enum AddressType {
    Postal
	Physical
	Both
}

enum ContributorType {
    Author
	Editor
	Reviewer
	Endorser
}

enum SortDirection {
    Ascending
	Descending
}

enum NameUse {
    Usual
	Official
	Temp
	Nickname
	Anonymous
	Old
	Maiden
}

enum ContactPointSystem {
    Phone
	Fax
	Email
	Pager
	Url
	Sms
	Other
}

enum ContactPointUse {
    Home
	Work
	Temp
	Old
	Mobile
}

enum IdentifierUse {
    Usual
	Official
	Temp
	Secondary
	Old
}

enum TriggerType {
    Named_Event
	Periodic
	Data_Changed
	Data_Added
	Data_Modified
	Data_Removed
	Data_Accessed
	Data_Access_Ended
}

enum QuantityComparator {
    Less_Than
	Less_Than_Or_Equal
	Greater_Than_Or_Equal
	Greater_Than
}

enum RelatedArtifactType {
    Documentation
	Justification
	Citation
	Predecessor
	Successor
	Derived_From
	Depends_On
	Composed_Of
}

enum ExpressionLanguage {
    Text_Cql
	Text_Fhirpath
	Application_X_Fhir_Query
}

enum UnitsOfTime {
    S
	Min
	H
	D
	Wk
	Mo
	A
}

enum EventTiming {
    MORN
	MORN_Early
	MORN_Late
	NOON
	AFT
	AFT_Early
	AFT_Late
	EVE
	EVE_Early
	EVE_Late
	NIGHT
	PHS
	HS
	WAKE
	C
	CM
	CD
	CV
	AC
	ACM
	ACD
	ACV
	PC
	PCM
	PCD
	PCV
}

enum PropertyRepresentation {
    XmlAttr
	XmlText
	TypeAttr
	CdaText
	Xhtml
}

enum ConstraintSeverity {
    Error
	Warning
}

enum AggregationMode {
    Contained
	Referenced
	Bundled
}

enum ReferenceVersionRules {
    Either
	Independent
	Specific
}

enum SlicingRules {
    Closed
	Open
	OpenAtEnd
}

enum BindingStrength {
    Required
	Extensible
	Preferred
	Example
}

enum DiscriminatorType {
    Value
	Exists
	Pattern
	Type
	Profile
}

enum PublicationStatus {
    Draft
	Active
	Retired
	Unknown
}

enum SearchParamType {
    Number
	Date
	String
	Token
	Reference
	Composite
	Quantity
	Uri
	Special
}

enum AdministrativeGender {
    Male
	Female
	Other
	Unknown
}

enum FHIRVersion {
    FHIRVersion_0_01
	FHIRVersion_0_05
	FHIRVersion_0_06
	FHIRVersion_0_11
	FHIRVersion_0_0_80
	FHIRVersion_0_0_81
	FHIRVersion_0_0_82
	FHIRVersion_0_4_0
	FHIRVersion_0_5_0
	FHIRVersion_1_0_0
	FHIRVersion_1_0_1
	FHIRVersion_1_0_2
	FHIRVersion_1_1_0
	FHIRVersion_1_4_0
	FHIRVersion_1_6_0
	FHIRVersion_1_8_0
	FHIRVersion_3_0_0
	FHIRVersion_3_0_1
	FHIRVersion_3_3_0
	FHIRVersion_3_5_0
	FHIRVersion_4_0_0
	FHIRVersion_4_0_1
}

enum NoteType {
    Display
	Print
	Printoper
}

enum RemittanceOutcome {
    Queued
	Complete
	Error
	Partial
}

enum ConceptMapEquivalence {
    Relatedto
	Equivalent
	Equal
	Wider
	Subsumes
	Narrower
	Specializes
	Inexact
	Unmatched
	Disjoint
}

enum DocumentReferenceStatus {
    Current
	Superseded
	Entered_In_Error
}

enum AccountStatus {
    Active
	Inactive
	Entered_In_Error
	On_Hold
	Unknown
}

enum ActionParticipantType {
    Patient
	Practitioner
	Related_Person
	Device
}

enum RequestIntent {
    Proposal
	Plan
	Directive
	Order_
	Original_Order_
	Reflex_Order_
	Filler_Order_
	Instance_Order_
	Option
}

enum RequestResourceType {
    Appointment
	AppointmentResponse
	CarePlan
	Claim
	CommunicationRequest
	Contract
	DeviceRequest
	EnrollmentRequest
	ImmunizationRecommendation
	MedicationRequest
	NutritionOrder_
	ServiceRequest
	SupplyRequest
	Task
	VisionPrescription
}

enum RequestPriority {
    Routine
	Urgent
	Asap
	Stat
}

enum AdverseEventActuality {
    Actual
	Potential
}

enum AllergyIntoleranceCriticality {
    Low
	High
	Unable_To_Assess
}

enum AllergyIntoleranceType {
    Allergy
	Intolerance
}

enum AllergyIntoleranceCategory {
    Food
	Medication
	Environment
	Biologic
}

enum AllergyIntoleranceSeverity {
    Mild
	Moderate
	Severe
}

enum ParticipantRequired {
    Required
	Optional
	Information_Only
}

enum AppointmentStatus {
    Proposed
	Pending
	Booked
	Arrived
	Fulfilled
	Cancelled
	Noshow
	Entered_In_Error
	Checked_In
	Waitlist
}

enum ParticipationStatus {
    Accepted
	Declined
	Tentative
	Needs_Action
}

enum AuditEventOutcome {
    AuditEventOutcome_0
	AuditEventOutcome_4
	AuditEventOutcome_8
	AuditEventOutcome_12
}

enum AuditEventAction {
    C
	R
	U
	D
	E
}

enum AuditEventAgentNetworkType {
    AuditEventAgentNetworkType_1
	AuditEventAgentNetworkType_2
	AuditEventAgentNetworkType_3
	AuditEventAgentNetworkType_4
	AuditEventAgentNetworkType_5
}

enum BiologicallyDerivedProductCategory {
    Organ
	Tissue
	Fluid
	Cells
	BiologicalAgent
}

enum BiologicallyDerivedProductStatus {
    Available
	Unavailable
}

enum BiologicallyDerivedProductStorageScale {
    Farenheit
	Celsius
	Kelvin
}

enum HTTPVerb {
    GET
	HEAD
	POST
	PUT
	DELETE
	PATCH
}

enum BundleType {
    Document
	Message
	Transaction
	Transaction_Response
	Batch
	Batch_Response
	History
	Searchset
	Collection
}

enum SearchEntryMode {
    Match
	Include
	Outcome
}

enum CapabilityStatementKind {
    Instance
	Capability
	Requirements
}

enum EventCapabilityMode {
    Sender
	Receiver
}

enum ResourceVersionPolicy {
    No_Version
	Versioned
	Versioned_Update
}

enum DocumentMode {
    Producer
	Consumer
}

enum RestfulCapabilityMode {
    Client
	Server
}

enum TypeRestfulInteraction {
    Read
	Vread
	Update
	Patch_
	Delete
	History_Instance
	History_Type
	Create
	Search_Type
}

enum SystemRestfulInteraction {
    Transaction
	Batch
	Search_System
	History_System
}

enum ConditionalReadStatus {
    Not_Supported
	Modified_Since
	Not_Match
	Full_Support
}

enum ReferenceHandlingPolicy {
    Literal
	Logical
	Resolves
	Enforced
	Local
}

enum ConditionalDeleteStatus {
    Not_Supported
	Single
	Multiple
}

enum CarePlanActivityKind {
    Appointment
	CommunicationRequest
	DeviceRequest
	MedicationRequest
	NutritionOrder_
	Task
	ServiceRequest
	VisionPrescription
}

enum CarePlanActivityStatus {
    Not_Started
	Scheduled
	In_Progress
	On_Hold
	Completed
	Cancelled
	Stopped
	Unknown
	Entered_In_Error
}

enum CarePlanIntent {
    Proposal
	Plan
	Order_
	Option
}

enum RequestStatus {
    Draft
	Active
	On_Hold
	Revoked
	Completed
	Entered_In_Error
	Unknown
}

enum CareTeamStatus {
    Proposed
	Active
	Suspended
	Inactive
	Entered_In_Error
}

enum CatalogEntryRelationType {
    Triggers
	Is_Replaced_By
}

enum ChargeItemStatus {
    Planned
	Billable
	Not_Billable
	Aborted
	Billed
	Entered_In_Error
	Unknown
}

enum InvoicePriceComponentType {
    Base
	Surcharge
	Deduction
	Discount
	Tax
	Informational
}

enum Use {
    Claim
	Preauthorization
	Predetermination
}

enum FinancialResourceStatusCodes {
    Active
	Cancelled
	Draft
	Entered_In_Error
}

enum ClaimProcessingCodes {
    Queued
	Complete
	Error
	Partial
}

enum ClinicalImpressionStatus {
    In_Progress
	Completed
	Entered_In_Error
}

enum FilterOperator {
    Equal
	Is_A
	Descendent_Of
	Is_Not_A
	Regex
	In
	Not_In
	Generalizes
	Exists
}

enum PropertyType {
    Code
	Coding
	String
	Integer
	Boolean
	DateTime
	Decimal
}

enum CodeSystemHierarchyMeaning {
    Grouped_By
	Is_A
	Part_Of
	Classified_With
}

enum CodeSystemContentMode {
    Not_Present
	Example
	Fragment
	Complete
	Supplement
}

enum EventStatus {
    Preparation
	In_Progress
	Not_Done
	On_Hold
	Stopped
	Completed
	Entered_In_Error
	Unknown
}

enum CompartmentType {
    Patient
	Encounter
	RelatedPerson
	Practitioner
	Device
}

enum VConfidentialityClassification {
    U
	L
	M
	N
	R
	V
}

enum CompositionStatus {
    Preliminary
	Final
	Amended
	Entered_In_Error
}

enum DocumentRelationshipType {
    Replaces
	Transforms
	Signs
	Appends
}

enum CompositionAttestationMode {
    Personal
	Professional
	Legal
	Official
}

enum ListMode {
    Working
	Snapshot
	Changes
}

enum ConceptMapGroupUnmappedMode {
    Provided
	Fixed
	Other_Map
}

enum ConsentProvisionType {
    Deny
	Permit
}

enum ConsentDataMeaning {
    Instance
	Related
	Dependents
	Authoredby
}

enum ConsentState {
    Draft
	Proposed
	Active
	Rejected
	Inactive
	Entered_In_Error
}

enum ContractResourceStatusCodes {
    Amended
	Appended
	Cancelled
	Disputed
	Entered_In_Error
	Executable
	Executed
	Negotiable
	Offered
	Policy
	Rejected
	Renewed
	Revoked
	Resolved
	Terminated
}

enum ContractResourcePublicationStatusCodes {
    Amended
	Appended
	Cancelled
	Disputed
	Entered_In_Error
	Executable
	Executed
	Negotiable
	Offered
	Policy
	Rejected
	Renewed
	Revoked
	Resolved
	Terminated
}

enum EligibilityRequestPurpose {
    Auth_Requirements
	Benefits
	Discovery
	Validation
}

enum EligibilityResponsePurpose {
    Auth_Requirements
	Benefits
	Discovery
	Validation
}

enum ObservationStatus {
    Registered
	Preliminary
	Final
	Amended
	Corrected
	Cancelled
	Entered_In_Error
	Unknown
}

enum DetectedIssueSeverity {
    High
	Moderate
	Low
}

enum FHIRDeviceStatus {
    Active
	Inactive
	Entered_In_Error
	Unknown
}

enum DeviceNameType {
    Udi_Label_Name
	User_Friendly_Name
	Patient_Reported_Name
	Manufacturer_Name
	Model_Name
	Other
}

enum UDIEntryType {
    Barcode
	Rfid
	Manual
	Card
	Self_Reported
	Unknown
}

enum DeviceMetricCalibrationType {
    Unspecified
	Offset
	Gain
	Two_Point
}

enum DeviceMetricColor {
    Black
	Red
	Green
	Yellow
	Blue
	Magenta
	Cyan
	White
}

enum DeviceMetricCalibrationState {
    Not_Calibrated
	Calibration_Required
	Calibrated
	Unspecified
}

enum DeviceMetricOperationalStatus {
    On
	Off
	Standby
	Entered_In_Error
}

enum DeviceMetricCategory {
    Measurement
	Setting
	Calculation
	Unspecified
}

enum DeviceUseStatementStatus {
    Active
	Completed
	Entered_In_Error
	Intended
	Stopped
	On_Hold
}

enum DiagnosticReportStatus {
    Registered
	Partial
	Preliminary
	Final
	Amended
	Corrected
	Appended
	Cancelled
	Entered_In_Error
	Unknown
}

enum ExposureState {
    Exposure
	Exposure_Alternative
}

enum EncounterLocationStatus {
    Planned
	Active
	Reserved
	Completed
}

enum EncounterStatus {
    Planned
	Arrived
	Triaged
	In_Progress
	Onleave
	Finished
	Cancelled
	Entered_In_Error
	Unknown
}

enum EndpointStatus {
    Active
	Suspended
	Error
	Off
	Entered_In_Error
	Test
}

enum EpisodeOfCareStatus {
    Planned
	Waitlist
	Active
	Onhold
	Finished
	Cancelled
	Entered_In_Error
}

enum EvidenceVariableType {
    Dichotomous
	Continuous
	Descriptive
}

enum GroupMeasure {
    Mean
	Median
	Mean_Of_Mean
	Mean_Of_Median
	Median_Of_Mean
	Median_Of_Median
}

enum ExampleScenarioActorType {
    Person
	Entity
}

enum ResourceType {
    Account
	ActivityDefinition
	AdverseEvent
	AllergyIntolerance
	Appointment
	AppointmentResponse
	AuditEvent
	Basic
	Binary
	BiologicallyDerivedProduct
	BodyStructure
	Bundle
	CapabilityStatement
	CarePlan
	CareTeam
	CatalogEntry
	ChargeItem
	ChargeItemDefinition
	Claim
	ClaimResponse
	ClinicalImpression
	CodeSystem
	Communication
	CommunicationRequest
	CompartmentDefinition
	Composition
	ConceptMap
	Condition
	Consent
	Contract
	Coverage
	CoverageEligibilityRequest
	CoverageEligibilityResponse
	DetectedIssue
	Device
	DeviceDefinition
	DeviceMetric
	DeviceRequest
	DeviceUseStatement
	DiagnosticReport
	DocumentManifest
	DocumentReference
	DomainResource
	EffectEvidenceSynthesis
	Encounter
	Endpoint
	EnrollmentRequest
	EnrollmentResponse
	EpisodeOfCare
	EventDefinition
	Evidence
	EvidenceVariable
	ExampleScenario
	ExplanationOfBenefit
	FamilyMemberHistory
	Flag
	Goal
	GraphDefinition
	Group
	GuidanceResponse
	HealthcareService
	ImagingStudy
	Immunization
	ImmunizationEvaluation
	ImmunizationRecommendation
	ImplementationGuide
	InsurancePlan
	Invoice
	Library
	Linkage
	List
	Location
	Measure
	MeasureReport
	Media
	Medication
	MedicationAdministration
	MedicationDispense
	MedicationKnowledge
	MedicationRequest
	MedicationStatement
	MedicinalProduct
	MedicinalProductAuthorization
	MedicinalProductContraindication
	MedicinalProductIndication
	MedicinalProductIngredient
	MedicinalProductInteraction
	MedicinalProductManufactured
	MedicinalProductPackaged
	MedicinalProductPharmaceutical
	MedicinalProductUndesirableEffect
	MessageDefinition
	MessageHeader
	MolecularSequence
	NamingSystem
	NutritionOrder_
	Observation
	ObservationDefinition
	OperationDefinition
	OperationOutcome
	Organization
	OrganizationAffiliation
	Parameters
	Patient
	PaymentNotice
	PaymentReconciliation
	Person
	PlanDefinition
	Practitioner
	PractitionerRole
	Procedure
	Provenance
	Questionnaire
	QuestionnaireResponse
	RelatedPerson
	RequestGroup
	ResearchDefinition
	ResearchElementDefinition
	ResearchStudy
	ResearchSubject
	Resource
	RiskAssessment
	RiskEvidenceSynthesis
	Schedule
	SearchParameter
	ServiceRequest
	Slot
	Specimen
	SpecimenDefinition
	StructureDefinition
	StructureMap
	Subscription_
	Substance
	SubstanceNucleicAcid
	SubstancePolymer
	SubstanceProtein
	SubstanceReferenceInformation
	SubstanceSourceMaterial
	SubstanceSpecification
	SupplyDelivery
	SupplyRequest
	Task
	TerminologyCapabilities
	TestReport
	TestScript
	ValueSet
	VerificationResult
	VisionPrescription
}

enum ExplanationOfBenefitStatus {
    Active
	Cancelled
	Draft
	Entered_In_Error
}

enum FamilyHistoryStatus {
    Partial
	Completed
	Entered_In_Error
	Health_Unknown
}

enum FlagStatus {
    Active
	Inactive
	Entered_In_Error
}

enum GoalLifecycleStatus {
    Proposed
	Planned
	Accepted
	Active
	On_Hold
	Completed
	Cancelled
	Entered_In_Error
	Rejected
}

enum GraphCompartmentUse {
    Condition
	Requirement
}

enum GraphCompartmentRule {
    Identical
	Matching
	Different
	Custom
}

enum GroupType {
    Person
	Animal
	Practitioner
	Device
	Medication
	Substance
}

enum GuidanceResponseStatus {
    Success
	Data_Requested
	Data_Required
	In_Progress
	Failure
	Entered_In_Error
}

enum DaysOfWeek {
    Mon
	Tue
	Wed
	Thu
	Fri
	Sat
	Sun
}

enum ImagingStudyStatus {
    Registered
	Available
	Cancelled
	Entered_In_Error
	Unknown
}

enum ImmunizationStatusCodes {
    Completed
	Entered_In_Error
	Not_Done
}

enum ImmunizationEvaluationStatusCodes {
    Completed
	Entered_In_Error
}

enum GuideParameterCode {
    Apply
	Path_Resource
	Path_Pages
	Path_Tx_Cache
	Expansion_Parameter
	Rule_Broken_Links
	Generate_Xml
	Generate_Json
	Generate_Turtle
	Html_Template
}

enum SPDXLicense {
    Not_Open_Source
	SPDXLicense_0BSD
	AAL
	Abstyles
	Adobe_2006
	Adobe_Glyph
	ADSL
	AFL_1_1
	AFL_1_2
	AFL_2_0
	AFL_2_1
	AFL_3_0
	Afmparse
	AGPL_1_0_Only
	AGPL_1_0_Or_Later
	AGPL_3_0_Only
	AGPL_3_0_Or_Later
	Aladdin
	AMDPLPA
	AML
	AMPAS
	ANTLR_PD
	Apache_1_0
	Apache_1_1
	Apache_2_0
	APAFML
	APL_1_0
	APSL_1_0
	APSL_1_1
	APSL_1_2
	APSL_2_0
	Artistic_1_0_Cl8
	Artistic_1_0_Perl
	Artistic_1_0
	Artistic_2_0
	Bahyph
	Barr
	Beerware
	BitTorrent_1_0
	BitTorrent_1_1
	Borceux
	BSD_1_Clause
	BSD_2_Clause_FreeBSD
	BSD_2_Clause_NetBSD
	BSD_2_Clause_Patent
	BSD_2_Clause
	BSD_3_Clause_Attribution
	BSD_3_Clause_Clear
	BSD_3_Clause_LBNL
	BSD_3_Clause_No_Nuclear_License_2014
	BSD_3_Clause_No_Nuclear_License
	BSD_3_Clause_No_Nuclear_Warranty
	BSD_3_Clause
	BSD_4_Clause_UC
	BSD_4_Clause
	BSD_Protection
	BSD_Source_Code
	BSL_1_0
	Bzip2_1_0_5
	Bzip2_1_0_6
	Caldera
	CATOSL_1_1
	CC_BY_1_0
	CC_BY_2_0
	CC_BY_2_5
	CC_BY_3_0
	CC_BY_4_0
	CC_BY_NC_1_0
	CC_BY_NC_2_0
	CC_BY_NC_2_5
	CC_BY_NC_3_0
	CC_BY_NC_4_0
	CC_BY_NC_ND_1_0
	CC_BY_NC_ND_2_0
	CC_BY_NC_ND_2_5
	CC_BY_NC_ND_3_0
	CC_BY_NC_ND_4_0
	CC_BY_NC_SA_1_0
	CC_BY_NC_SA_2_0
	CC_BY_NC_SA_2_5
	CC_BY_NC_SA_3_0
	CC_BY_NC_SA_4_0
	CC_BY_ND_1_0
	CC_BY_ND_2_0
	CC_BY_ND_2_5
	CC_BY_ND_3_0
	CC_BY_ND_4_0
	CC_BY_SA_1_0
	CC_BY_SA_2_0
	CC_BY_SA_2_5
	CC_BY_SA_3_0
	CC_BY_SA_4_0
	CC0_1_0
	CDDL_1_0
	CDDL_1_1
	CDLA_Permissive_1_0
	CDLA_Sharing_1_0
	CECILL_1_0
	CECILL_1_1
	CECILL_2_0
	CECILL_2_1
	CECILL_B
	CECILL_C
	ClArtistic
	CNRI_Jython
	CNRI_Python_GPL_Compatible
	CNRI_Python
	Condor_1_1
	CPAL_1_0
	CPL_1_0
	CPOL_1_02
	Crossword
	CrystalStacker
	CUA_OPL_1_0
	Cube
	Curl
	D_FSL_1_0
	Diffmark
	DOC
	Dotseqn
	DSDP
	Dvipdfm
	ECL_1_0
	ECL_2_0
	EFL_1_0
	EFL_2_0
	EGenix
	Entessa
	EPL_1_0
	EPL_2_0
	ErlPL_1_1
	EUDatagrid
	EUPL_1_0
	EUPL_1_1
	EUPL_1_2
	Eurosym
	Fair
	Frameworx_1_0
	FreeImage
	FSFAP
	FSFUL
	FSFULLR
	FTL
	GFDL_1_1_Only
	GFDL_1_1_Or_Later
	GFDL_1_2_Only
	GFDL_1_2_Or_Later
	GFDL_1_3_Only
	GFDL_1_3_Or_Later
	Giftware
	GL2PS
	Glide
	Glulxe
	Gnuplot
	GPL_1_0_Only
	GPL_1_0_Or_Later
	GPL_2_0_Only
	GPL_2_0_Or_Later
	GPL_3_0_Only
	GPL_3_0_Or_Later
	GSOAP_1_3b
	HaskellReport
	HPND
	IBM_Pibs
	ICU
	IJG
	ImageMagick
	IMatix
	Imlib2
	Info_ZIP
	Intel_ACPI
	Intel
	Interbase_1_0
	IPA
	IPL_1_0
	ISC
	JasPer_2_0
	JSON
	LAL_1_2
	LAL_1_3
	Latex2e
	Leptonica
	LGPL_2_0_Only
	LGPL_2_0_Or_Later
	LGPL_2_1_Only
	LGPL_2_1_Or_Later
	LGPL_3_0_Only
	LGPL_3_0_Or_Later
	LGPLLR
	Libpng
	Libtiff
	LiLiQ_P_1_1
	LiLiQ_R_1_1
	LiLiQ_Rplus_1_1
	Linux_OpenIB
	LPL_1_0
	LPL_1_02
	LPPL_1_0
	LPPL_1_1
	LPPL_1_2
	LPPL_1_3a
	LPPL_1_3c
	MakeIndex
	MirOS
	MIT_0
	MIT_Advertising
	MIT_CMU
	MIT_Enna
	MIT_Feh
	MIT
	MITNFA
	Motosoto
	Mpich2
	MPL_1_0
	MPL_1_1
	MPL_2_0_No_Copyleft_Exception
	MPL_2_0
	MS_PL
	MS_RL
	MTLL
	Multics
	Mup
	NASA_1_3
	Naumen
	NBPL_1_0
	NCSA
	Net_SNMP
	NetCDF
	Newsletr
	NGPL
	NLOD_1_0
	NLPL
	Nokia
	NOSL
	Noweb
	NPL_1_0
	NPL_1_1
	NPOSL_3_0
	NRL
	NTP
	OCCT_PL
	OCLC_2_0
	ODbL_1_0
	OFL_1_0
	OFL_1_1
	OGTSL
	OLDAP_1_1
	OLDAP_1_2
	OLDAP_1_3
	OLDAP_1_4
	OLDAP_2_0_1
	OLDAP_2_0
	OLDAP_2_1
	OLDAP_2_2_1
	OLDAP_2_2_2
	OLDAP_2_2
	OLDAP_2_3
	OLDAP_2_4
	OLDAP_2_5
	OLDAP_2_6
	OLDAP_2_7
	OLDAP_2_8
	OML
	OpenSSL
	OPL_1_0
	OSET_PL_2_1
	OSL_1_0
	OSL_1_1
	OSL_2_0
	OSL_2_1
	OSL_3_0
	PDDL_1_0
	PHP_3_0
	PHP_3_01
	Plexus
	PostgreSQL
	Psfrag
	Psutils
	Python_2_0
	Qhull
	QPL_1_0
	Rdisc
	RHeCos_1_1
	RPL_1_1
	RPL_1_5
	RPSL_1_0
	RSA_MD
	RSCPL
	Ruby
	SAX_PD
	Saxpath
	SCEA
	Sendmail
	SGI_B_1_0
	SGI_B_1_1
	SGI_B_2_0
	SimPL_2_0
	SISSL_1_2
	SISSL
	Sleepycat
	SMLNJ
	SMPPL
	SNIA
	Spencer_86
	Spencer_94
	Spencer_99
	SPL_1_0
	SugarCRM_1_1_3
	SWL
	TCL
	TCP_Wrappers
	TMate
	TORQUE_1_1
	TOSL
	Unicode_DFS_2015
	Unicode_DFS_2016
	Unicode_TOU
	Unlicense
	UPL_1_0
	Vim
	VOSTROM
	VSL_1_0
	W3C_19980720
	W3C_20150513
	W3C
	Watcom_1_0
	Wsuipa
	WTFPL
	X11
	Xerox
	XFree86_1_1
	Xinetd
	Xnet
	Xpp
	XSkat
	YPL_1_0
	YPL_1_1
	Zed
	Zend_2_0
	Zimbra_1_3
	Zimbra_1_4
	Zlib_Acknowledgement
	Zlib
	ZPL_1_1
	ZPL_2_0
	ZPL_2_1
}

enum GuidePageGeneration {
    Html
	Markdown
	Xml
	Generated
}

enum InvoiceStatus {
    Draft
	Issued
	Balanced
	Cancelled
	Entered_In_Error
}

enum LinkageType {
    Source
	Alternate
	Historical
}

enum ListStatus {
    Current
	Retired
	Entered_In_Error
}

enum LocationMode {
    Instance
	Kind
}

enum LocationStatus {
    Active
	Suspended
	Inactive
}

enum MeasureReportStatus {
    Complete
	Pending
	Error
}

enum MeasureReportType {
    Individual
	Subject_List
	Summary
	Data_Collection
}

enum MedicationStatusCodes {
    Active
	Inactive
	Entered_In_Error
}

enum MedicationrequestStatus {
    Active
	On_Hold
	Cancelled
	Completed
	Entered_In_Error
	Stopped
	Draft
	Unknown
}

enum MedicationRequestIntent {
    Proposal
	Plan
	Order_
	Original_Order_
	Reflex_Order_
	Filler_Order_
	Instance_Order_
	Option
}

enum MessageSignificanceCategory {
    Consequence
	Currency
	Notification
}

enum MessageheaderResponseRequest {
    Always
	On_Error
	Never
	On_Success
}

enum ResponseType {
    Ok
	Transient_Error
	Fatal_Error
}

enum StrandType {
    Watson
	Crick
}

enum OrientationType {
    Sense
	Antisense
}

enum RepositoryType {
    Directlink
	Openapi
	Login
	Oauth
	Other
}

enum QualityType {
    Indel
	Snp
	Unknown
}

enum SequenceType {
    Aa
	Dna
	Rna
}

enum NamingSystemIdentifierType {
    Oid
	Uuid
	Uri
	Other
}

enum NamingSystemType {
    Codesystem
	Identifier
	Root
}

enum ObservationDataType {
    Quantity
	CodeableConcept
	String
	Boolean
	Integer
	Range
	Ratio
	SampledData
	Time
	DateTime
	Period
}

enum ObservationRangeCategory {
    Reference
	Critical
	Absolute
}

enum OperationParameterUse {
    In
	Out
}

enum OperationKind {
    Operation
	Query
}

enum IssueType {
    Invalid
	Structure
	Required
	Value
	Invariant
	Security
	Login
	Unknown
	Expired
	Forbidden
	Suppressed
	Processing
	Not_Supported
	Duplicate
	Multiple_Matches
	Not_Found
	Deleted
	Too_Long
	Code_Invalid
	Extension
	Too_Costly
	Business_Rule
	Conflict
	Transient
	Lock_Error
	No_Store
	Exception
	Timeout
	Incomplete
	Throttled
	Informational
}

enum IssueSeverity {
    Fatal
	Error
	Warning
	Information
}

enum LinkType {
    Replaced_By
	Replaces
	Refer
	Seealso
}

enum IdentityAssuranceLevel {
    Level1
	Level2
	Level3
	Level4
}

enum ActionRequiredBehavior {
    Must
	Could
	Must_Unless_Documented
}

enum ActionRelationshipType {
    Before_Start
	Before
	Before_End
	Concurrent_With_Start
	Concurrent
	Concurrent_With_End
	After_Start
	After
	After_End
}

enum ActionGroupingBehavior {
    Visual_Group
	Logical_Group
	Sentence_Group
}

enum ActionSelectionBehavior {
    Any
	All
	All_Or_None
	Exactly_One
	At_Most_One
	One_Or_More
}

enum ActionCardinalityBehavior {
    Single
	Multiple
}

enum ActionPrecheckBehavior {
    Yes
	No
}

enum ActionConditionKind {
    Applicability
	Start
	Stop
}

enum ProvenanceEntityRole {
    Derivation
	Revision
	Quotation
	Source
	Removal
}

enum QuestionnaireItemType {
    Group
	Display
	Boolean
	Decimal
	Integer
	Date
	DateTime
	Time
	String
	Text
	Url
	Choice
	Open_Choice
	Attachment
	Reference
	Quantity
}

enum EnableWhenBehavior {
    All
	Any
}

enum QuestionnaireItemOperator {
    Exists
	Equal
	Not_Equal
	Greater_Than
	Less_Than
	Greater_Than_Or_Equal
	Less_Than_Or_Equal
}

enum QuestionnaireResponseStatus {
    In_Progress
	Completed
	Amended
	Entered_In_Error
	Stopped
}

enum ResearchElementType {
    Population
	Exposure
	Outcome
}

enum VariableType {
    Dichotomous
	Continuous
	Descriptive
}

enum ResearchStudyStatus {
    Active
	Administratively_Completed
	Approved
	Closed_To_Accrual
	Closed_To_Accrual_And_Intervention
	Completed
	Disapproved
	In_Review
	Temporarily_Closed_To_Accrual
	Temporarily_Closed_To_Accrual_And_Intervention
	Withdrawn
}

enum ResearchSubjectStatus {
    Candidate
	Eligible
	Follow_Up
	Ineligible
	Not_Registered
	Off_Study
	On_Study
	On_Study_Intervention
	On_Study_Observation
	Pending_On_Study
	Potential_Candidate
	Screening
	Withdrawn
}

enum XPathUsageType {
    Normal
	Phonetic
	Nearby
	Distance
	Other
}

enum SearchModifierCode {
    Missing
	Exact
	Contains
	Not
	Text
	In
	Not_In
	Below
	Above
	Type
	Identifier
	OfType
}

enum SearchComparator {
    Eq
	Ne
	Gt
	Lt
	Ge
	Le
	Sa
	Eb
	Ap
}

enum SlotStatus {
    Busy
	Free
	Busy_Unavailable
	Busy_Tentative
	Entered_In_Error
}

enum SpecimenStatus {
    Available
	Unavailable
	Unsatisfactory
	Entered_In_Error
}

enum SpecimenContainedPreference {
    Preferred
	Alternate
}

enum StructureDefinitionKind {
    Primitive_Type
	Complex_Type
	Resource
	Logical
}

enum TypeDerivationRule {
    Specialization
	Constraint
}

enum ExtensionContextType {
    Fhirpath
	Element
	Extension
}

enum StructureMapInputMode {
    Source
	Target
}

enum StructureMapContextType {
    Type
	Variable
}

enum StructureMapTargetListMode {
    First
	Share
	Last
	Collate
}

enum StructureMapTransform {
    Create
	Copy
	Truncate
	Escape
	Cast
	Append
	Translate
	Reference
	DateOp
	Uuid
	Pointer
	Evaluate
	Cc
	C
	Qty
	Id
	Cp
}

enum StructureMapSourceListMode {
    First
	Not_First
	Last
	Not_Last
	Only_One
}

enum StructureMapGroupTypeMode {
    None
	Types
	Type_And_Types
}

enum StructureMapModelMode {
    Source
	Queried
	Target
	Produced
}

enum SubscriptionStatus {
    Requested
	Active
	Error
	Off
}

enum SubscriptionChannelType {
    Rest_Hook
	Websocket
	Email
	Sms
	Message
}

enum FHIRSubstanceStatus {
    Active
	Inactive
	Entered_In_Error
}

enum SupplyDeliveryStatus {
    In_Progress
	Completed
	Abandoned
	Entered_In_Error
}

enum SupplyRequestStatus {
    Draft
	Active
	Suspended
	Cancelled
	Completed
	Entered_In_Error
	Unknown
}

enum TaskStatus {
    Draft
	Requested
	Received
	Accepted
	Rejected
	Ready
	Cancelled
	In_Progress
	On_Hold
	Failed
	Completed
	Entered_In_Error
}

enum TaskIntent {
    Unknown
	Proposal
	Plan
	Order_
	Original_Order_
	Reflex_Order_
	Filler_Order_
	Instance_Order_
	Option
}

enum CodeSearchSupport {
    Explicit
	All
}

enum TestReportStatus {
    Completed
	In_Progress
	Waiting
	Stopped
	Entered_In_Error
}

enum TestReportActionResult {
    Pass
	Skip
	Fail
	Warning
	Error
}

enum TestReportParticipantType {
    Test_Engine
	Client
	Server
}

enum TestReportResult {
    Pass
	Fail
	Pending
}

enum AssertionDirectionType {
    Response
	Request
}

enum AssertionOperatorType {
    Equals
	NotEquals
	In
	NotIn
	GreaterThan
	LessThan
	Empty
	NotEmpty
	Contains
	NotContains
	Eval
}

enum AssertionResponseTypes {
    Okay
	Created
	NoContent
	NotModified
	Bad
	Forbidden
	NotFound
	MethodNotAllowed
	Conflict
	Gone
	PreconditionFailed
	Unprocessable
}

enum TestScriptRequestMethodCode {
    Delete
	Get
	Options
	Patch_
	Post
	Put
	Head
}

enum Status {
    Attested
	Validated
	In_Process
	Req_Revalid
	Val_Fail
	Reval_Fail
}

enum VisionBase {
    Up
	Down
	In
	Out
}

enum VisionEyes {
    Right
	Left
}

enum ResourceContainer {
    Account
	ActivityDefinition
	AdverseEvent
	AllergyIntolerance
	Appointment
	AppointmentResponse
	AuditEvent
	Basic
	Binary
	BiologicallyDerivedProduct
	BodyStructure
	Bundle
	CapabilityStatement
	CarePlan
	CareTeam
	CatalogEntry
	ChargeItem
	ChargeItemDefinition
	Claim
	ClaimResponse
	ClinicalImpression
	CodeSystem
	Communication
	CommunicationRequest
	CompartmentDefinition
	Composition
	ConceptMap
	Condition
	Consent
	Contract
	Coverage
	CoverageEligibilityRequest
	CoverageEligibilityResponse
	DetectedIssue
	Device
	DeviceDefinition
	DeviceMetric
	DeviceRequest
	DeviceUseStatement
	DiagnosticReport
	DocumentManifest
	DocumentReference
	EffectEvidenceSynthesis
	Encounter
	Endpoint
	EnrollmentRequest
	EnrollmentResponse
	EpisodeOfCare
	EventDefinition
	Evidence
	EvidenceVariable
	ExampleScenario
	ExplanationOfBenefit
	FamilyMemberHistory
	Flag
	Goal
	GraphDefinition
	Group
	GuidanceResponse
	HealthcareService
	ImagingStudy
	Immunization
	ImmunizationEvaluation
	ImmunizationRecommendation
	ImplementationGuide
	InsurancePlan
	Invoice
	Library
	Linkage
	List
	Location
	Measure
	MeasureReport
	Media
	Medication
	MedicationAdministration
	MedicationDispense
	MedicationKnowledge
	MedicationRequest
	MedicationStatement
	MedicinalProduct
	MedicinalProductAuthorization
	MedicinalProductContraindication
	MedicinalProductIndication
	MedicinalProductIngredient
	MedicinalProductInteraction
	MedicinalProductManufactured
	MedicinalProductPackaged
	MedicinalProductPharmaceutical
	MedicinalProductUndesirableEffect
	MessageDefinition
	MessageHeader
	MolecularSequence
	NamingSystem
	NutritionOrder_
	Observation
	ObservationDefinition
	OperationDefinition
	OperationOutcome
	Organization
	OrganizationAffiliation
	Patient
	PaymentNotice
	PaymentReconciliation
	Person
	PlanDefinition
	Practitioner
	PractitionerRole
	Procedure
	Provenance
	Questionnaire
	QuestionnaireResponse
	RelatedPerson
	RequestGroup
	ResearchDefinition
	ResearchElementDefinition
	ResearchStudy
	ResearchSubject
	RiskAssessment
	RiskEvidenceSynthesis
	Schedule
	SearchParameter
	ServiceRequest
	Slot
	Specimen
	SpecimenDefinition
	StructureDefinition
	StructureMap
	Subscription_
	Substance
	SubstanceNucleicAcid
	SubstancePolymer
	SubstanceProtein
	SubstanceReferenceInformation
	SubstanceSourceMaterial
	SubstanceSpecification
	SupplyDelivery
	SupplyRequest
	Task
	TerminologyCapabilities
	TestReport
	TestScript
	ValueSet
	VerificationResult
	VisionPrescription
	Parameters
}

#----------------------------------*** Schema Definition Completed ***----------------------------------

#----------------------------------*** Schema Definition Started ***----------------------------------

# ----------------------------------------
# Author: Santa Basnet
# Company: WiseYak Inc.
# Date: Fri Sep 10 01:33:13 NPT 2021
# ----------------------------------------


#--------------------------------------*** Union Types Section ***-------------------------------------
        

union ContractActionContext = Encounter | EpisodeOfCare

union ObservationDevice = Device | DeviceMetric

union ObservationHasMember = MolecularSequence | Observation | QuestionnaireResponse

union ServiceRequestPerformer = CareTeam | Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CoverageEligibilityRequestProvider = Organization | Practitioner | PractitionerRole

union ClinicalImpressionInvestigationItem = DiagnosticReport | FamilyMemberHistory | ImagingStudy | Media | Observation | QuestionnaireResponse | RiskAssessment

union ObservationPartOf = ImagingStudy | Immunization | MedicationAdministration | MedicationDispense | MedicationStatement | Procedure

union AppointmentReasonReference = Condition | ImmunizationRecommendation | Observation | Procedure

union ClinicalImpressionProblem = AllergyIntolerance | Condition

union MedicinalProductContraindicationSubject = Medication | MedicinalProduct

union ContractContentDefinitionPublisher = Organization | Practitioner | PractitionerRole

union MedicationStatementInformationSource = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ImagingStudyReferrer = Practitioner | PractitionerRole

union QuestionnaireResponsePartOf = Observation | Procedure

union ClaimProvider = Organization | Practitioner | PractitionerRole

union GoalSubject = Group | Organization | Patient

union ContractActionPerformer = CareTeam | Device | Location | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson | Substance

union SupplyRequestReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union DeviceUseStatementSubject = Group | Patient

union AdverseEventSuspectEntityInstance = Device | Immunization | Medication | MedicationAdministration | MedicationStatement | Procedure | Substance

union AppointmentResponseActor = Device | HealthcareService | Location | Patient | Practitioner | PractitionerRole | RelatedPerson

union ClaimPayeeParty = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CommunicationRequestRequester = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union SupplyDeliveryReceiver = Practitioner | PractitionerRole

union MedicationRequestRecorder = Practitioner | PractitionerRole

union ClinicalImpressionFindingItemReference = Condition | Media | Observation

union RequestGroupSubject = Group | Patient

union ResearchStudyPrincipalInvestigator = Practitioner | PractitionerRole

union ContractSignerParty = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CatalogEntryReferencedItem = ActivityDefinition | Binary | Device | HealthcareService | Medication | ObservationDefinition | Organization | PlanDefinition | Practitioner | PractitionerRole | SpecimenDefinition

union AppointmentParticipantActor = Device | HealthcareService | Location | Patient | Practitioner | PractitionerRole | RelatedPerson

union ExplanationOfBenefitCareTeamProvider = Organization | Practitioner | PractitionerRole

union ContractSubjectReference = Device | Group | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union DocumentReferenceAuthenticator = Organization | Practitioner | PractitionerRole

union RiskAssessmentReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union SupplyRequestDeliverFrom = Location | Organization

union ContractAuthor = Organization | Patient | Practitioner | PractitionerRole

union ContractPartyReference = Device | Group | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ChargeItemService = DiagnosticReport | ImagingStudy | Immunization | MedicationAdministration | MedicationDispense | Observation | Procedure | SupplyDelivery

union DiagnosticReportBasedOn = CarePlan | ImmunizationRecommendation | MedicationRequest | NutritionOrder_ | ServiceRequest

union ProcedurePerformerActor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ClinicalImpressionSubject = Group | Patient

union CoverageEligibilityRequestItemProvider = Practitioner | PractitionerRole

union MeasureReportReporter = Location | Organization | Practitioner | PractitionerRole

union AdverseEventCausalityAuthor = Practitioner | PractitionerRole

union CoverageEligibilityRequestEnterer = Practitioner | PractitionerRole

union DetectedIssueMitigationAuthor = Practitioner | PractitionerRole

union GuidanceResponseReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union ConditionRecorder = Patient | Practitioner | PractitionerRole | RelatedPerson

union EnrollmentResponseRequestProvider = Organization | Practitioner | PractitionerRole

union CarePlanActivityReference = Appointment | CommunicationRequest | DeviceRequest | MedicationRequest | NutritionOrder_ | RequestGroup | ServiceRequest | Task | VisionPrescription

union DiagnosticReportResultsInterpreter = CareTeam | Organization | Practitioner | PractitionerRole

union PersonLinkTarget = Patient | Person | Practitioner | RelatedPerson

union RiskAssessmentPerformer = Device | Practitioner | PractitionerRole

union DeviceUseStatementSource = Patient | Practitioner | PractitionerRole | RelatedPerson

union BasicAuthor = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ImmunizationReasonReference = Condition | DiagnosticReport | Observation

union ImagingStudyInterpreter = Practitioner | PractitionerRole

union ConsentPerformer = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union PaymentReconciliationDetailPayee = Organization | Practitioner | PractitionerRole

union ExplanationOfBenefitPayeeParty = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ExplanationOfBenefitProvider = Organization | Practitioner | PractitionerRole

union ProvenanceAgentWho = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MediaBasedOn = CarePlan | ServiceRequest

union MessageHeaderSender = Organization | Practitioner | PractitionerRole

union MedicationDispenseReceiver = Patient | Practitioner

union ProcedureRecorder = Patient | Practitioner | PractitionerRole | RelatedPerson

union CarePlanAuthor = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationRequestPerformer = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CareTeamParticipantMember = CareTeam | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union PaymentReconciliationRequestor = Organization | Practitioner | PractitionerRole

union PaymentNoticePayee = Organization | Practitioner | PractitionerRole

union ExplanationOfBenefitEnterer = Practitioner | PractitionerRole

union EpisodeOfCareCareManager = Practitioner | PractitionerRole

union MedicationStatementPartOf = MedicationAdministration | MedicationDispense | MedicationStatement | Observation | Procedure

union ChargeItemDefinitionInstance = Device | Medication | Substance

union ServiceRequestReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union AuditEventSourceObserver = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union DocumentReferenceAuthor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ClinicalImpressionAssessor = Practitioner | PractitionerRole

union ClaimOriginalPrescription = DeviceRequest | MedicationRequest | VisionPrescription

union CommunicationSender = Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union DiagnosticReportSubject = Device | Group | Location | Patient

union EncounterHospitalizationDestination = Location | Organization

union RequestGroupReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union GuidanceResponseResult = CarePlan | RequestGroup

union MedicationRequestSubject = Group | Patient

union CoverageEligibilityRequestItemFacility = Location | Organization

union ProcedureReasonReference = Condition | DiagnosticReport | DocumentReference | Observation | Procedure

union ContractActionReasonReference = Condition | DiagnosticReport | DocumentReference | Observation | Questionnaire | QuestionnaireResponse

union MedicationAdministrationSubject = Group | Patient

union ImmunizationPerformerActor = Organization | Practitioner | PractitionerRole

union InvoiceParticipantActor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union GroupManagingEntity = Organization | Practitioner | PractitionerRole | RelatedPerson

union MedicinalProductInteractionInteractantItemReference = Medication | MedicinalProduct | ObservationDefinition | Substance

union AccountSubject = Device | HealthcareService | Location | Organization | Patient | Practitioner | PractitionerRole

union GoalAddresses = Condition | MedicationStatement | NutritionOrder_ | Observation | RiskAssessment | ServiceRequest

union EncounterHospitalizationOrigin = Location | Organization

union ConsentActorReference = CareTeam | Device | Group | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union EncounterDiagnosisCondition = Condition | Procedure

union DocumentReferenceContextEncounter = Encounter | EpisodeOfCare

union AllergyIntoleranceAsserter = Patient | Practitioner | PractitionerRole | RelatedPerson

union ChargeItemEnterer = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union GroupMemberEntity = Device | Group | Medication | Patient | Practitioner | PractitionerRole | Substance

union TaskInsurance = ClaimResponse | Coverage

union DeviceRequestReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union QuestionnaireResponseBasedOn = CarePlan | ServiceRequest

union EncounterReasonReference = Condition | ImmunizationRecommendation | Observation | Procedure

union CommunicationSubject = Group | Patient

union DeviceUseStatementReasonReference = Condition | DiagnosticReport | DocumentReference | Media | Observation

union CareTeamSubject = Group | Patient

union SupplyRequestDeliverTo = Location | Organization | Patient

union ClaimResponseAddItemProvider = Organization | Practitioner | PractitionerRole

union CoveragePolicyHolder = Organization | Patient | RelatedPerson

union ObservationDerivedFrom = DocumentReference | ImagingStudy | Media | MolecularSequence | Observation | QuestionnaireResponse

union MedicationKnowledgeMonographSource = DocumentReference | Media

union AuditEventAgentWho = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union TaskOwner = CareTeam | Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ConditionSubject = Group | Patient

union MedicationStatementBasedOn = CarePlan | MedicationRequest | ServiceRequest

union ConditionStageAssessment = ClinicalImpression | DiagnosticReport | Observation

union MeasureReportSubject = Device | Group | Location | Patient | Practitioner | PractitionerRole | RelatedPerson

union ConsentVerificationVerifiedWith = Patient | RelatedPerson

union CoverageEligibilityResponseItemProvider = Practitioner | PractitionerRole

union ServiceRequestSubject = Device | Group | Location | Patient

union ClaimCareTeamProvider = Organization | Practitioner | PractitionerRole

union MedicationRequestInsurance = ClaimResponse | Coverage

union FamilyMemberHistoryReasonReference = AllergyIntolerance | Condition | DiagnosticReport | DocumentReference | Observation | QuestionnaireResponse

union MediaSubject = Device | Group | Location | Patient | Practitioner | PractitionerRole | Specimen

union DeviceRequestPerformer = CareTeam | Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CoverageSubscriber = Patient | RelatedPerson

union MessageHeaderResponsible = Organization | Practitioner | PractitionerRole

union VerificationResultAttestationOnBehalfOf = Organization | Practitioner | PractitionerRole

union DeviceUseStatementDerivedFrom = Claim | DocumentReference | Observation | Procedure | QuestionnaireResponse | ServiceRequest

union MediaDevice = Device | DeviceMetric

union DetectedIssueAuthor = Device | Practitioner | PractitionerRole

union ClaimEnterer = Practitioner | PractitionerRole

union MedicationRequestReasonReference = Condition | Observation

union MedicinalProductIndicationSubject = Medication | MedicinalProduct

union DocumentManifestRecipient = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationAdministrationReasonReference = Condition | DiagnosticReport | Observation

union CarePlanDetailPerformer = CareTeam | Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationDispenseSubject = Group | Patient

union AdverseEventRecorder = Patient | Practitioner | PractitionerRole | RelatedPerson

union AdverseEventSubject = Group | Patient | Practitioner | RelatedPerson

union FlagSubject = Group | Location | Medication | Organization | Patient | PlanDefinition | Practitioner | Procedure

union DocumentManifestAuthor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ListSource = Device | Patient | Practitioner | PractitionerRole

union CommunicationRequestSender = Device | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CommunicationRequestSubject = Group | Patient

union SpecimenCollectionCollector = Practitioner | PractitionerRole

union CompositionSectionAuthor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CoverageEligibilityResponseRequestor = Organization | Practitioner | PractitionerRole

union QuestionnaireResponseAuthor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationStatementContext = Encounter | EpisodeOfCare

union ProcedureUsedReference = Device | Medication | Substance

union MessageHeaderDestinationReceiver = Organization | Practitioner | PractitionerRole

union ChargeItemPerformerActor = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ProcedureBasedOn = CarePlan | ServiceRequest

union ClaimPrescription = DeviceRequest | MedicationRequest | VisionPrescription

union MedicationStatementSubject = Group | Patient

union SupplyDeliveryPartOf = Contract | SupplyDelivery

union MediaOperator = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicinalProductInteractionSubject = Medication | MedicinalProduct | Substance

union AdverseEventSubjectMedicalHistory = AllergyIntolerance | Condition | DocumentReference | FamilyMemberHistory | Immunization | Media | Observation | Procedure

union ProcedureSubject = Group | Patient

union NutritionOrderOrderer = Practitioner | PractitionerRole

union SupplyRequestSupplier = HealthcareService | Organization

union VerificationResultPrimarySourceWho = Organization | Practitioner | PractitionerRole

union CarePlanDetailReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union AllergyIntoleranceRecorder = Patient | Practitioner | PractitionerRole | RelatedPerson

union ImagingStudyPerformerActor = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union AccountGuarantorParty = Organization | Patient | RelatedPerson

union VerificationResultAttestationWho = Organization | Practitioner | PractitionerRole

union MedicationAdministrationContext = Encounter | EpisodeOfCare

union VisionPrescriptionPrescriber = Practitioner | PractitionerRole

union LinkageAuthor = Organization | Practitioner | PractitionerRole

union InvoiceSubject = Group | Patient

union ContractValuedItemRecipient = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ImagingStudySubject = Device | Group | Patient

union MedicinalProductAuthorizationSubject = MedicinalProduct | MedicinalProductPackaged

union EnrollmentRequestProvider = Organization | Practitioner | PractitionerRole

union ConditionAsserter = Patient | Practitioner | PractitionerRole | RelatedPerson

union DocumentReferenceSubject = Device | Group | Patient | Practitioner

union TaskRequester = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ProcedurePartOf = MedicationAdministration | Observation | Procedure

union CommunicationRequestRecipient = CareTeam | Device | Group | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicinalProductUndesirableEffectSubject = Medication | MedicinalProduct

union ServiceRequestInsurance = ClaimResponse | Coverage

union ListSubject = Device | Group | Location | Patient

union CoveragePayor = Organization | Patient | RelatedPerson

union CarePlanSubject = Group | Patient

union ContractValuedItemResponsible = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union InvoiceRecipient = Organization | Patient | RelatedPerson

union PaymentNoticeProvider = Organization | Practitioner | PractitionerRole

union CompositionAttesterParty = Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationDispenseContext = Encounter | EpisodeOfCare

union MedicinalProductContact = Organization | PractitionerRole

union ImagingStudyReasonReference = Condition | DiagnosticReport | DocumentReference | Media | Observation

union ScheduleActor = Device | HealthcareService | Location | Patient | Practitioner | PractitionerRole | RelatedPerson

union ProcedureReport = Composition | DiagnosticReport | DocumentReference

union GuidanceResponseSubject = Group | Patient

union ExplanationOfBenefitAddItemProvider = Organization | Practitioner | PractitionerRole

union RiskAssessmentSubject = Group | Patient

union EncounterParticipantIndividual = Practitioner | PractitionerRole | RelatedPerson

union PaymentReconciliationDetailSubmitter = Organization | Practitioner | PractitionerRole

union ExplanationOfBenefitPrescription = MedicationRequest | VisionPrescription

union PatientGeneralPractitioner = Organization | Practitioner | PractitionerRole

union GoalExpressedBy = Patient | Practitioner | PractitionerRole | RelatedPerson

union BiologicallyDerivedProductCollectionCollector = Practitioner | PractitionerRole

union ImmunizationRecommendationRecommendationSupportingImmunization = Immunization | ImmunizationEvaluation

union MessageHeaderEnterer = Practitioner | PractitionerRole

union ProvenanceAgentOnBehalfOf = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union DocumentManifestSubject = Device | Group | Patient | Practitioner

union DeviceRequestRequester = Device | Organization | Practitioner | PractitionerRole

union MedicationAdministrationPerformerActor = Device | Patient | Practitioner | PractitionerRole | RelatedPerson

union CommunicationReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union DeviceRequestSubject = Device | Group | Location | Patient

union QuestionnaireResponseSource = Patient | Practitioner | PractitionerRole | RelatedPerson

union DeviceRequestInsurance = ClaimResponse | Coverage

union MedicationRequestRequester = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union RequestGroupActionParticipant = Device | Patient | Practitioner | PractitionerRole | RelatedPerson

union ChargeItemContext = Encounter | EpisodeOfCare

union MedicationRequestBasedOn = CarePlan | ImmunizationRecommendation | MedicationRequest | ServiceRequest

union ObservationBasedOn = CarePlan | DeviceRequest | ImmunizationRecommendation | MedicationRequest | NutritionOrder_ | ServiceRequest

union ImagingStudyBasedOn = Appointment | AppointmentResponse | CarePlan | ServiceRequest | Task

union ClaimResponseRequestor = Organization | Practitioner | PractitionerRole

union EncounterSubject = Group | Patient

union CarePlanContributor = CareTeam | Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union DiagnosticReportPerformer = CareTeam | Organization | Practitioner | PractitionerRole

union SubstanceSpecificationPropertyDefiningSubstanceReference = Substance | SubstanceSpecification

union ServiceRequestRequester = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union CompositionAuthor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ChargeItemSubject = Group | Patient

union RequestGroupAuthor = Device | Practitioner | PractitionerRole

union AdverseEventContributor = Device | Practitioner | PractitionerRole

union FlagAuthor = Device | Organization | Patient | Practitioner | PractitionerRole

union ServiceRequestBasedOn = CarePlan | MedicationRequest | ServiceRequest

union ObservationPerformer = CareTeam | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationDispensePerformerActor = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union BiologicallyDerivedProductCollectionSource = Organization | Patient

union MedicationAdministrationPartOf = MedicationAdministration | Procedure

union ObservationSubject = Device | Group | Location | Patient

union SupplyRequestRequester = Device | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MessageHeaderAuthor = Practitioner | PractitionerRole

union SpecimenSubject = Device | Group | Location | Patient | Substance

union PatientLinkOther = Patient | RelatedPerson

union CommunicationRecipient = CareTeam | Device | Group | HealthcareService | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationStatementReasonReference = Condition | DiagnosticReport | Observation

union SupplyDeliverySupplier = Organization | Practitioner | PractitionerRole

union TaskRestrictionRecipient = Group | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union ContractActionRequester = Device | Group | Organization | Patient | Practitioner | PractitionerRole | RelatedPerson

union MedicationDispenseSubstitutionResponsibleParty = Practitioner | PractitionerRole

union CommunicationRequestReasonReference = Condition | DiagnosticReport | DocumentReference | Observation

union ProcedureAsserter = Patient | Practitioner | PractitionerRole | RelatedPerson

union EvidenceVariableCharacteristicDefinitionReference = ActivityDefinition | Group

#----------------------------------*** Schema Definition Completed ***----------------------------------

#----------------------------------*** Schema Definition Started ***----------------------------------

# ----------------------------------------
# Author: Santa Basnet
# Company: WiseYak Inc.
# Date: Fri Sep 10 01:33:13 NPT 2021
# ----------------------------------------

#--------------------------------------*** Class Types Section ***-------------------------------------

type Attachment {
    size: Int
	url: String
	data: String
	creation: DateTime
	hash: String
	id: String! @id
	contentType: String @search(by: [exact])
	language: String
	title: String
}

type AuditEventDetail {
    id: String! @id
	type: String!
	valueString: String!
	valueBase64Binary: String!
}

type BundleLink {
    id: String! @id
	relation: String!
	url: String!
}

type CapabilityStatementOperation {
    id: String! @id
	name: String!
	definition: String!
	documentation: String
}

type CapabilityStatementSoftware {
    id: String! @id
	name: String! @search(by: [fulltext])
	version: String
	releaseDate: DateTime
}

type ChargeItemDefinitionApplicability {
    id: String! @id
	description: String
	language: String
	expression: String
}

type Coding {
    system: String
	userSelected: Boolean
	code: String
	version: String
	id: String! @id
	display: String @search(by: [fulltext])
}

type CompartmentDefinitionResource {
    id: String! @id
	code: String! @search(by: [exact])
	param: [String]
	documentation: String
}

type ConceptMapDependsOn {
    system: String
	id: String! @id
	property: String!
	value: String!
	display: String
}

type ConsentPolicy {
    id: String! @id
	authority: String
	uri: String
}

type DeviceDefinitionSpecialization {
    id: String! @id
	systemType: String!
	version: String
}

type DeviceDefinitionUdiDeviceIdentifier {
    id: String! @id
	deviceIdentifier: String!
	issuer: String!
	jurisdiction: String!
}

type EffectEvidenceSynthesisSampleSize {
    id: String! @id
	description: String
	numberOfStudies: Int
	numberOfParticipants: Int
}

type ElementDefinitionBase {
    id: String! @id
	path: String!
	min: Int!
	max: String!
}

type ElementDefinitionMapping {
    map: String!
	id: String! @id
	language: String
	comment: String
	identity: String!
}

type ExampleScenarioContainedInstance {
    id: String! @id
	resourceId: String!
	versionId: String
}

type ExampleScenarioVersion {
    id: String! @id
	versionId: String!
	description: String!
}

type ImmunizationEducation {
    reference: String
	id: String! @id
	publicationDate: DateTime
	documentType: String
	presentationDate: DateTime
}

type ImplementationGuideDependsOn {
    id: String! @id
	uri: String!
	packageId: String
	version: String
}

type ImplementationGuideGlobal {
    id: String! @id
	type: String!
	profile: String!
}

type ImplementationGuideGrouping {
    id: String! @id
	name: String!
	description: String
}

type ImplementationGuidePage1 {
    id: String! @id
	name: String!
	title: String
	anchor: [String]
}

type ImplementationGuideTemplate {
    id: String! @id
	code: String!
	source: String!
	scope: String
}

type LocationPosition {
    id: String! @id
	longitude: Float!
	latitude: Float!
	altitude: Float
}

type MedicationBatch {
    id: String! @id
	lotNumber: String @search(by: [exact])
	expirationDate: DateTime @search
}

type MessageDefinitionAllowedResponse {
    id: String! @id
	message: String!
	situation: String
}

type MessageDefinitionFocus {
    min: Int!
	code: String! @search(by: [exact])
	id: String! @id
	max: String
	profile: String
}

type MolecularSequenceInner {
    id: String! @id
	start: Int
	end: Int
}

type MolecularSequenceOuter {
    id: String! @id
	start: Int
	end: Int
}

type MolecularSequenceRoc {
    sensitivity: [Float]
	precision: [Float]
	numTP: [Int]
	score: [Int]
	numFP: [Int]
	id: String! @id
	fMeasure: [Float]
	numFN: [Int]
}

type Money {
    id: String! @id
	value: Float
	currency: String
}

type OperationDefinitionOverload {
    id: String! @id
	parameterName: [String]
	comment: String
}

type OperationDefinitionReferencedFrom {
    id: String! @id
	source: String!
	sourceId: String
}

type ParameterDefinition {
    name: String
	documentation: String
	min: Int
	id: String! @id
	max: String
	profile: String
	use: String!
	type: String!
}

type Period {
    id: String! @id
	start: DateTime
	end: DateTime
}

type RiskEvidenceSynthesisSampleSize {
    id: String! @id
	description: String
	numberOfStudies: Int
	numberOfParticipants: Int
}

type SearchParameterComponent {
    id: String! @id
	definition: String!
	expression: String!
}

type StructureDefinitionMapping {
    name: String
	uri: String
	id: String! @id
	comment: String
	identity: String!
}

type StructureMapDependent {
    id: String! @id
	name: String!
	variable: [String]
}

type StructureMapParameter {
    valueDecimal: Float!
	valueString: String!
	valueBoolean: Boolean!
	valueId: String!
	valueInteger: Int!
	id: String! @id
}

type TerminologyCapabilitiesClosure {
    id: String! @id
	translation: Boolean
}

type TerminologyCapabilitiesFilter_ {
    id: String! @id
	code: String!
	op: [String]
}

type TerminologyCapabilitiesImplementation {
    id: String! @id
	description: String!
	url: String
}

type TerminologyCapabilitiesParameter {
    id: String! @id
	name: String!
	documentation: String
}

type TerminologyCapabilitiesSoftware {
    id: String! @id
	name: String!
	version: String
}

type TerminologyCapabilitiesTranslation {
    id: String! @id
	needsMap: Boolean!
}

type TerminologyCapabilitiesValidateCode {
    id: String! @id
	translations: Boolean!
}

type TestScriptCapability {
    capabilities: String!
	description: String
	validated: Boolean!
	id: String! @id
	origin: [Int]
	link: [String]
	required: Boolean!
	destination: Int
}

type TestScriptLink {
    id: String! @id
	url: String!
	description: String
}

type TestScriptRequestHeader {
    id: String! @id
	field: String!
	value: String!
}

type TestScriptVariable {
    name: String!
	path: String
	description: String
	id: String! @id
	expression: String
	hint: String
	headerField: String
	defaultValue: String
	sourceId: String
}

type ValueSetParameter {
    valueDecimal: Float
	name: String!
	valueCode: String
	valueUri: String
	valueString: String
	valueBoolean: Boolean
	valueDateTime: DateTime
	valueInteger: Int
	id: String! @id
}

#----------------------------------*** Schema Definition Completed ***----------------------------------

#----------------------------------*** Schema Definition Started ***----------------------------------

# ----------------------------------------
# Author: Santa Basnet
# Company: WiseYak Inc.
# Date: Fri Sep 10 01:33:13 NPT 2021
# ----------------------------------------

#--------------------------------------*** Class Types Section ***-------------------------------------

type Account {
    name: String @search(by: [fulltext])
	subject: [AccountSubject]
	identifier: [Identifier]
	description: String
	guarantor: [AccountGuarantor]
	coverage: [AccountCoverage]
	id: String! @id
	status: AccountStatus!
	servicePeriod: Period
	partOf: Account
	owner: Organization
	type: CodeableConcept
}

type AccountCoverage {
    id: String! @id
	coverage: Coverage!
	priority: Int
}

type AccountGuarantor {
    id: String! @id
	party: AccountGuarantorParty!
	onHold: Boolean
	period: Period
}

type ActivityDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	participant: [ActivityDefinitionParticipant]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	quantity: Quantity
	priority: RequestPriority
	location: Location
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	intent: RequestIntent
	observationResultRequirement: [ObservationDefinition]
	description: String @search(by: [fulltext])
	usage: String
	effectivePeriod: Period
	endorser: [ContactDetail]
	contact: [ContactDetail]
	specimenRequirement: [SpecimenDefinition]
	purpose: String
	code: CodeableConcept
	doNotPerform: Boolean
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	profile: String
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	library: [String]
	dynamicValue: [ActivityDefinitionDynamicValue]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	dosage: [Dosage]
	kind: RequestResourceType
	title: String @search(by: [fulltext])
	bodySite: [CodeableConcept]
	transform: String
	observationRequirement: [ObservationDefinition]
}

type ActivityDefinitionDynamicValue {
    id: String! @id
	path: String!
	expression: Expression!
}

type ActivityDefinitionParticipant {
    id: String! @id
	type: ActionParticipantType!
	role: CodeableConcept
}

type Address {
    city: String @search(by: [fulltext])
	state: String @search(by: [fulltext])
	line: [String]
	text: String
	country: String @search(by: [fulltext])
	postalCode: String @search(by: [fulltext])
	id: String! @id
	use: AddressUse
	type: AddressType
	district: String
	period: Period
}

type AdverseEvent {
    contributor: [AdverseEventContributor]
	location: Location
	subject: AdverseEventSubject!
	suspectEntity: [AdverseEventSuspectEntity]
	identifier: Identifier
	event: CodeableConcept
	subjectMedicalHistory: [AdverseEventSubjectMedicalHistory]
	recordedDate: DateTime
	outcome: CodeableConcept
	referenceDocument: [DocumentReference]
	resultingCondition: [Condition]
	id: String! @id
	detected: DateTime
	date: DateTime @search
	category: [CodeableConcept]
	seriousness: CodeableConcept
	severity: CodeableConcept
	actuality: AdverseEventActuality!
	encounter: Encounter
	study: [ResearchStudy]
	recorder: AdverseEventRecorder
}

type AdverseEventCausality {
    method: CodeableConcept
	author: AdverseEventCausalityAuthor
	productRelatedness: String
	id: String! @id
	assessment: CodeableConcept
}

type AdverseEventSuspectEntity {
    id: String! @id
	instance: AdverseEventSuspectEntityInstance!
	causality: [AdverseEventCausality]
}

type Age {
    system: String
	code: String
	id: String! @id
	unit: String
	comparator: QuantityComparator
	value: Float
}

type AllergyIntolerance {
    verificationStatus: CodeableConcept
	clinicalStatus: CodeableConcept
	identifier: [Identifier]
	recordedDate: DateTime @search
	reaction: [AllergyIntoleranceReaction]
	code: CodeableConcept
	id: String! @id
	note: [Annotation]
	lastOccurrence: DateTime @search
	category: [AllergyIntoleranceCategory]
	type: AllergyIntoleranceType
	criticality: AllergyIntoleranceCriticality
	encounter: Encounter
	asserter: AllergyIntoleranceAsserter
	recorder: AllergyIntoleranceRecorder
	patient: Patient!
}

type AllergyIntoleranceReaction {
    exposureRoute: CodeableConcept
	substance: CodeableConcept
	description: String
	id: String! @id
	manifestation: [CodeableConcept]
	note: [Annotation]
	onset: DateTime @search
	severity: AllergyIntoleranceSeverity
}

type Annotation {
    text: String! @search(by: [fulltext])
	authorString: String
	id: String! @id
	time: DateTime
	authorReference: Reference
}

type Appointment {
    participant: [AppointmentParticipant]
	serviceType: [CodeableConcept]
	priority: Int
	minutesDuration: Int
	serviceCategory: [CodeableConcept]
	appointmentType: CodeableConcept
	identifier: [Identifier]
	cancelationReason: CodeableConcept
	description: String
	specialty: [CodeableConcept]
	reasonCode: [CodeableConcept]
	id: String! @id
	status: AppointmentStatus!
	comment: String
	requestedPeriod: [Period]
	patientInstruction: String
	basedOn: [ServiceRequest]
	supportingInformation: [Resource]
	end: DateTime
	start: DateTime @search
	slot: [Slot]
	reasonReference: [AppointmentReasonReference]
	created: DateTime
}

type AppointmentResponse {
    actor: AppointmentResponseActor
	identifier: [Identifier]
	participantType: [CodeableConcept]
	id: String! @id
	comment: String
	end: DateTime
	participantStatus: ParticipationStatus!
	appointment: Appointment!
	start: DateTime
}

type AppointmentParticipant {
    actor: AppointmentParticipantActor
	id: String! @id
	status: ParticipationStatus!
	type: [CodeableConcept]
	required: ParticipantRequired
	period: Period
}

type AuditEvent {
    source: AuditEventSource!
	purposeOfEvent: [CodeableConcept]
	subtype: [Coding]
	outcomeDesc: String
	outcome: AuditEventOutcome
	agent: [AuditEventAgent]
	id: String! @id
	recorded: DateTime! @search
	entity: [AuditEventEntity]
	type: Coding!
	action: AuditEventAction
	period: Period
}

type AuditEventAgent {
    altId: String @search(by: [exact])
	requestor: Boolean!
	network: AuditEventNetwork
	name: String @search(by: [fulltext])
	location: Location
	role: [CodeableConcept]
	id: String! @id
	who: AuditEventAgentWho
	media: Coding
	type: CodeableConcept
	purposeOfUse: [CodeableConcept]
	policy: [String] @search(by: [exact])
}

type AuditEventEntity {
    name: String @search(by: [fulltext])
	lifecycle: Coding
	role: Coding
	what: Resource
	description: String
	securityLabel: [Coding]
	query: String
	id: String! @id
	detail: [AuditEventDetail]
	type: Coding
}

type AuditEventNetwork {
    id: String! @id
	address: String
	type: AuditEventAgentNetworkType
}

type AuditEventSource {
    id: String! @id
	site: String @search(by: [exact])
	observer: AuditEventSourceObserver!
	type: [Coding]
}

type BackboneElement {
    id: String! @id
	modifierExtension: [Extension]
}

type Basic {
    author: BasicAuthor
	subject: Resource
	identifier: [Identifier]
	code: CodeableConcept!
	id: String! @id
	created: DateTime @search
}

type Binary {
    id: String! @id
	contentType: String!
	securityContext: Resource
	data: String
}

type BiologicallyDerivedProduct {
    parent: [BiologicallyDerivedProduct]
	quantity: Int
	request: [ServiceRequest]
	collection: BiologicallyDerivedProductCollection
	identifier: [Identifier]
	manipulation: BiologicallyDerivedProductManipulation
	processing: [BiologicallyDerivedProductProcessing]
	id: String! @id
	status: BiologicallyDerivedProductStatus
	productCategory: BiologicallyDerivedProductCategory
	storage: [BiologicallyDerivedProductStorage]
	productCode: CodeableConcept
}

type BiologicallyDerivedProductCollection {
    collector: BiologicallyDerivedProductCollectionCollector
	source: BiologicallyDerivedProductCollectionSource
	collectedDateTime: DateTime
	collectedPeriod: Period
	id: String! @id
}

type BiologicallyDerivedProductManipulation {
    id: String! @id
	description: String
	timeDateTime: DateTime
	timePeriod: Period
}

type BiologicallyDerivedProductProcessing {
    timeDateTime: DateTime
	description: String
	additive: Substance
	procedure: CodeableConcept
	id: String! @id
	timePeriod: Period
}

type BiologicallyDerivedProductStorage {
    duration: Period
	description: String
	scale: BiologicallyDerivedProductStorageScale
	temperature: Float
	id: String! @id
}

type BodyStructure {
    location: CodeableConcept
	locationQualifier: [CodeableConcept]
	identifier: [Identifier]
	image: [Attachment]
	description: String
	id: String! @id
	morphology: CodeableConcept
	patient: Patient!
	active: Boolean
}

type Bundle {
    timestamp: DateTime @search
	identifier: Identifier
	entry: [BundleEntry]
	signature: Signature
	total: Int
	id: String! @id
	link: [BundleLink]
	type: BundleType!
}

type BundleEntry {
    request: BundleRequest
	response: BundleResponse
	id: String! @id
	resource: ResourceContainer
	fullUrl: String
	link: [BundleLink]
	search: BundleSearch
}

type BundleRequest {
    ifMatch: String
	method: HTTPVerb!
	url: String!
	id: String! @id
	ifNoneMatch: String
	ifNoneExist: String
	ifModifiedSince: DateTime
}

type BundleResponse {
    etag: String
	location: String
	lastModified: DateTime
	outcome: ResourceContainer
	id: String! @id
	status: String!
}

type BundleSearch {
    id: String! @id
	mode: SearchEntryMode
	score: Float
}

type CapabilityStatement {
    copyright: String
	jurisdiction: [CodeableConcept]
	format: [String] @search(by: [exact])
	experimental: Boolean
	name: String @search(by: [fulltext])
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	document: [CapabilityStatementDocument]
	messaging: [CapabilityStatementMessaging]
	rest: [CapabilityStatementRest]
	implementationGuide: [String]
	fhirVersion: FHIRVersion!
	contact: [ContactDetail]
	purpose: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	implementation: CapabilityStatementImplementation
	instantiates: [String]
	date: DateTime! @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	software: CapabilityStatementSoftware
	kind: CapabilityStatementKind!
	title: String @search(by: [fulltext])
	patchFormat: [String]
	imports: [String]
}

type CapabilityStatementDocument {
    id: String! @id
	mode: DocumentMode!
	documentation: String
	profile: String!
}

type CapabilityStatementEndpoint {
    id: String! @id
	protocol: Coding!
	address: String!
}

type CapabilityStatementImplementation {
    id: String! @id
	description: String!
	url: String
	custodian: Organization
}

type CapabilityStatementInteraction {
    id: String! @id
	code: TypeRestfulInteraction!
	documentation: String
}

type CapabilityStatementInteraction1 {
    id: String! @id
	code: SystemRestfulInteraction!
	documentation: String
}

type CapabilityStatementMessaging {
    reliableCache: Int
	documentation: String
	id: String! @id
	endpoint: [CapabilityStatementEndpoint]
	supportedMessage: [CapabilityStatementSupportedMessage]
}

type CapabilityStatementResource {
    searchInclude: [String]
	searchRevInclude: [String]
	versioning: ResourceVersionPolicy
	updateCreate: Boolean
	interaction: [CapabilityStatementInteraction]
	conditionalUpdate: Boolean
	documentation: String
	conditionalCreate: Boolean
	supportedProfile: [String]
	searchParam: [CapabilityStatementSearchParam]
	conditionalDelete: ConditionalDeleteStatus
	id: String! @id
	operation: [CapabilityStatementOperation]
	profile: String
	conditionalRead: ConditionalReadStatus
	referencePolicy: [ReferenceHandlingPolicy]
	type: String!
	readHistory: Boolean
}

type CapabilityStatementRest {
    interaction: [CapabilityStatementInteraction1]
	security: CapabilityStatementSecurity
	documentation: String
	searchParam: [CapabilityStatementSearchParam]
	id: String! @id
	operation: [CapabilityStatementOperation]
	resource: [CapabilityStatementResource]
	mode: RestfulCapabilityMode!
	compartment: [String]
}

type CapabilityStatementSearchParam {
    name: String!
	documentation: String
	id: String! @id
	definition: String
	type: SearchParamType!
}

type CapabilityStatementSecurity {
    id: String! @id
	cors: Boolean
	service: [CodeableConcept]
	description: String
}

type CapabilityStatementSupportedMessage {
    id: String! @id
	mode: EventCapabilityMode!
	definition: String!
}

type CarePlan {
    author: CarePlanAuthor
	supportingInfo: [Resource]
	contributor: [CarePlanContributor]
	subject: CarePlanSubject!
	instantiatesUri: [String] @search(by: [exact])
	identifier: [Identifier]
	intent: CarePlanIntent!
	description: String
	goal: [Goal]
	id: String! @id
	note: [Annotation]
	status: RequestStatus!
	partOf: [CarePlan]
	category: [CodeableConcept]
	basedOn: [CarePlan]
	title: String
	activity: [CarePlanActivity]
	instantiatesCanonical: [String]
	encounter: Encounter
	careTeam: [CareTeam]
	replaces: [CarePlan]
	period: Period
	created: DateTime
	addresses: [Condition]
}

type CarePlanActivity {
    reference: CarePlanActivityReference
	outcomeReference: [Resource]
	outcomeCodeableConcept: [CodeableConcept]
	id: String! @id
	progress: [Annotation]
	detail: CarePlanDetail
}

type CarePlanDetail {
    quantity: Quantity
	statusReason: CodeableConcept
	location: Location
	scheduledTiming: Timing
	instantiatesUri: [String]
	description: String
	goal: [Goal]
	reasonCode: [CodeableConcept]
	productReference: Reference
	scheduledString: String
	code: CodeableConcept
	doNotPerform: Boolean
	id: String! @id
	dailyAmount: Quantity
	status: CarePlanActivityStatus!
	productCodeableConcept: CodeableConcept
	kind: CarePlanActivityKind
	scheduledPeriod: Period
	reasonReference: [CarePlanDetailReasonReference]
	instantiatesCanonical: [String]
	performer: [CarePlanDetailPerformer]
}

type CareTeam {
    participant: [CareTeamParticipant]
	name: String
	subject: CareTeamSubject
	identifier: [Identifier]
	reasonCode: [CodeableConcept]
	id: String! @id
	note: [Annotation]
	status: CareTeamStatus
	telecom: [ContactPoint]
	category: [CodeableConcept]
	reasonReference: [Condition]
	encounter: Encounter
	managingOrganization: [Organization]
	period: Period
}

type CareTeamParticipant {
    role: [CodeableConcept]
	onBehalfOf: Organization
	id: String! @id
	member: CareTeamParticipantMember
	period: Period
}

type CatalogEntry {
    validityPeriod: Period
	identifier: [Identifier]
	lastUpdated: DateTime
	additionalClassification: [CodeableConcept]
	validTo: DateTime
	relatedEntry: [CatalogEntryRelatedEntry]
	orderable: Boolean!
	id: String! @id
	referencedItem: CatalogEntryReferencedItem!
	additionalCharacteristic: [CodeableConcept]
	status: PublicationStatus
	additionalIdentifier: [Identifier]
	classification: [CodeableConcept]
	type: CodeableConcept
}

type CatalogEntryRelatedEntry {
    id: String! @id
	relationtype: CatalogEntryRelationType!
	item: CatalogEntry!
}

type ChargeItem {
    quantity: Quantity
	subject: ChargeItemSubject!
	identifier: [Identifier]
	context: ChargeItemContext
	requestingOrganization: Organization
	costCenter: Organization
	reason: [CodeableConcept]
	service: [ChargeItemService]
	enteredDate: DateTime @search
	code: CodeableConcept!
	id: String! @id
	note: [Annotation]
	status: ChargeItemStatus!
	bodysite: [CodeableConcept]
	partOf: [ChargeItem]
	definitionCanonical: [String]
	priceOverride: Money
	supportingInformation: [Resource]
	definitionUri: [String]
	account: [Account]
	factorOverride: Float @search
	overrideReason: String
	enterer: ChargeItemEnterer
	performer: [ChargeItemPerformer]
	performingOrganization: Organization
}

type ChargeItemDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	applicability: [ChargeItemDefinitionApplicability]
	experimental: Boolean
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	effectivePeriod: Period
	propertyGroup: [ChargeItemDefinitionPropertyGroup]
	instance: [ChargeItemDefinitionInstance]
	contact: [ContactDetail]
	code: CodeableConcept
	derivedFromUri: [String]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	partOf: [String]
	title: String @search(by: [fulltext])
	replaces: [String]
}

type ChargeItemDefinitionPriceComponent {
    amount: Money
	factor: Float
	code: CodeableConcept
	id: String! @id
	type: InvoicePriceComponentType!
}

type ChargeItemDefinitionPropertyGroup {
    id: String! @id
	applicability: [ChargeItemDefinitionApplicability]
	priceComponent: [ChargeItemDefinitionPriceComponent]
}

type ChargeItemPerformer {
    id: String! @id
	function: CodeableConcept
	actor: ChargeItemPerformerActor!
}

type Claim {
    accident: ClaimAccident
	originalPrescription: ClaimOriginalPrescription
	supportingInfo: [ClaimSupportingInfo]
	priority: CodeableConcept!
	diagnosis: [ClaimDiagnosis]
	provider: ClaimProvider!
	insurance: [ClaimInsurance]
	identifier: [Identifier]
	prescription: ClaimPrescription
	procedure: [ClaimProcedure]
	total: Money
	referral: ServiceRequest
	id: String! @id
	related: [ClaimRelated]
	billablePeriod: Period
	status: FinancialResourceStatusCodes!
	use: Use!
	type: CodeableConcept!
	facility: Location
	subType: CodeableConcept
	insurer: Organization
	enterer: ClaimEnterer
	fundsReserve: CodeableConcept
	careTeam: [ClaimCareTeam]
	payee: ClaimPayee
	created: DateTime! @search
	patient: Patient!
	item: [ClaimItem]
}

type ClaimResponse {
    requestor: ClaimResponseRequestor
	payeeType: CodeableConcept
	request: Claim
	insurance: [ClaimResponseInsurance]
	identifier: [Identifier]
	disposition: String @search(by: [fulltext])
	outcome: ClaimProcessingCodes!
	total: [ClaimResponseTotal]
	preAuthPeriod: Period
	preAuthRef: String
	communicationRequest: [CommunicationRequest]
	payment: ClaimResponsePayment
	id: String! @id
	processNote: [ClaimResponseProcessNote]
	formCode: CodeableConcept
	error: [ClaimResponseError]
	status: FinancialResourceStatusCodes!
	use: Use!
	addItem: [ClaimResponseAddItem]
	type: CodeableConcept!
	form: Attachment
	subType: CodeableConcept
	insurer: Organization!
	adjudication: [ClaimResponseAdjudication]
	fundsReserve: CodeableConcept
	created: DateTime! @search
	patient: Patient!
	item: [ClaimResponseItem]
}

type ClaimResponseAddItem {
    quantity: Quantity
	locationReference: Reference
	provider: [ClaimResponseAddItemProvider]
	subSite: [CodeableConcept]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	locationAddress: Address
	itemSequence: [Int]
	id: String! @id
	servicedPeriod: Period
	detailSequence: [Int]
	modifier: [CodeableConcept]
	detail: [ClaimResponseDetail1]
	servicedDate: DateTime
	unitPrice: Money
	noteNumber: [Int]
	bodySite: CodeableConcept
	subdetailSequence: [Int]
	adjudication: [ClaimResponseAdjudication]
	locationCodeableConcept: CodeableConcept
}

type ClaimResponseAdjudication {
    reason: CodeableConcept
	amount: Money
	id: String! @id
	category: CodeableConcept!
	value: Float
}

type ClaimResponseDetail {
    subDetail: [ClaimResponseSubDetail]
	id: String! @id
	detailSequence: Int!
	noteNumber: [Int]
	adjudication: [ClaimResponseAdjudication]
}

type ClaimResponseDetail1 {
    quantity: Quantity
	subDetail: [ClaimResponseSubDetail1]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ClaimResponseAdjudication]
}

type ClaimResponseError {
    code: CodeableConcept!
	itemSequence: Int
	id: String! @id
	detailSequence: Int
	subDetailSequence: Int
}

type ClaimResponseInsurance {
    claimResponse: ClaimResponse
	businessArrangement: String
	focal: Boolean!
	coverage: Coverage!
	id: String! @id
	sequence: Int!
}

type ClaimResponseItem {
    itemSequence: Int!
	id: String! @id
	detail: [ClaimResponseDetail]
	noteNumber: [Int]
	adjudication: [ClaimResponseAdjudication]
}

type ClaimResponsePayment {
    identifier: Identifier
	adjustment: Money
	amount: Money!
	id: String! @id
	date: DateTime @search
	type: CodeableConcept!
	adjustmentReason: CodeableConcept
}

type ClaimResponseProcessNote {
    number: Int
	text: String!
	id: String! @id
	language: CodeableConcept
	type: NoteType
}

type ClaimResponseSubDetail {
    id: String! @id
	subDetailSequence: Int!
	noteNumber: [Int]
	adjudication: [ClaimResponseAdjudication]
}

type ClaimResponseSubDetail1 {
    quantity: Quantity
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ClaimResponseAdjudication]
}

type ClaimResponseTotal {
    id: String! @id
	category: CodeableConcept!
	amount: Money!
}

type ClaimAccident {
    locationReference: Reference
	locationAddress: Address
	id: String! @id
	date: DateTime!
	type: CodeableConcept
}

type ClaimCareTeam {
    provider: ClaimCareTeamProvider!
	qualification: CodeableConcept
	role: CodeableConcept
	responsible: Boolean
	id: String! @id
	sequence: Int!
}

type ClaimDetail {
    quantity: Quantity
	subDetail: [ClaimSubDetail]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	sequence: Int!
	revenue: CodeableConcept
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	unitPrice: Money
}

type ClaimDiagnosis {
    packageCode: CodeableConcept
	diagnosisReference: Reference!
	diagnosisCodeableConcept: CodeableConcept!
	onAdmission: CodeableConcept
	id: String! @id
	sequence: Int!
	type: [CodeableConcept]
}

type ClaimInsurance {
    claimResponse: ClaimResponse
	businessArrangement: String
	focal: Boolean!
	identifier: Identifier
	coverage: Coverage!
	preAuthRef: [String]
	id: String! @id
	sequence: Int!
}

type ClaimItem {
    quantity: Quantity
	locationReference: Reference
	procedureSequence: [Int]
	careTeamSequence: [Int]
	subSite: [CodeableConcept]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	locationAddress: Address
	id: String! @id
	sequence: Int!
	servicedPeriod: Period
	revenue: CodeableConcept
	informationSequence: [Int]
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	detail: [ClaimDetail]
	servicedDate: DateTime
	unitPrice: Money
	bodySite: CodeableConcept
	diagnosisSequence: [Int]
	encounter: [Encounter]
	locationCodeableConcept: CodeableConcept
}

type ClaimPayee {
    id: String! @id
	type: CodeableConcept!
	party: ClaimPayeeParty
}

type ClaimProcedure {
    procedureCodeableConcept: CodeableConcept!
	id: String! @id
	sequence: Int!
	date: DateTime
	procedureReference: Reference!
	udi: [Device]
	type: [CodeableConcept]
}

type ClaimRelated {
    id: String! @id
	claim: Claim
	relationship: CodeableConcept
	reference: Identifier
}

type ClaimSubDetail {
    quantity: Quantity
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	sequence: Int!
	revenue: CodeableConcept
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	unitPrice: Money
}

type ClaimSupportingInfo {
    timingPeriod: Period
	valueQuantity: Quantity
	valueString: String
	valueBoolean: Boolean
	reason: CodeableConcept
	code: CodeableConcept
	id: String! @id
	sequence: Int!
	valueReference: Reference
	timingDate: DateTime
	category: CodeableConcept!
	valueAttachment: Attachment
}

type ClinicalImpression {
    supportingInfo: [Resource]
	statusReason: CodeableConcept
	subject: ClinicalImpressionSubject!
	identifier: [Identifier]
	problem: [ClinicalImpressionProblem]
	description: String
	previous: ClinicalImpression
	investigation: [ClinicalImpressionInvestigation]
	prognosisCodeableConcept: [CodeableConcept]
	assessor: ClinicalImpressionAssessor
	finding: [ClinicalImpressionFinding]
	code: CodeableConcept
	id: String! @id
	date: DateTime @search
	note: [Annotation]
	status: ClinicalImpressionStatus!
	encounter: Encounter
	prognosisReference: [RiskAssessment]
	protocol: [String]
	summary: String
}

type ClinicalImpressionFinding {
    id: String! @id
	itemCodeableConcept: CodeableConcept
	itemReference: ClinicalImpressionFindingItemReference
	basis: String
}

type ClinicalImpressionInvestigation {
    id: String! @id
	code: CodeableConcept!
	item: [ClinicalImpressionInvestigationItem]
}

type CodeSystem {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String @search(by: [fulltext])
	count: Int
	supplements: String
	valueSet: String
	hierarchyMeaning: CodeSystemHierarchyMeaning
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	compositional: Boolean
	purpose: String
	caseSensitive: Boolean
	filter: [CodeSystemFilter_]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	content: CodeSystemContentMode!
	concept: [CodeSystemConcept]
	property: [CodeSystemProperty]
	title: String @search(by: [fulltext])
	versionNeeded: Boolean
}

type CodeSystemConcept {
    designation: [CodeSystemDesignation]
	code: String! @search(by: [exact])
	id: String! @id
	definition: String
	concept: [CodeSystemConcept]
	property: [CodeSystemProperty1]
	display: String
}

type CodeSystemDesignation {
    id: String! @id
	language: String
	use: Coding
	value: String!
}

type CodeSystemFilter_ {
    description: String
	code: String!
	id: String! @id
	operator: [FilterOperator]
	value: String!
}

type CodeSystemProperty {
    description: String
	uri: String
	code: String!
	id: String! @id
	type: PropertyType!
}

type CodeSystemProperty1 {
    valueDecimal: Float!
	valueCode: String!
	valueString: String!
	valueBoolean: Boolean!
	code: String!
	valueDateTime: DateTime!
	valueInteger: Int!
	id: String! @id
	valueCoding: Coding!
}

type CodeableConcept {
    id: String! @id
	coding: [Coding]
	text: String @search(by: [fulltext])
}

type Communication {
    recipient: [CommunicationRecipient]
	priority: RequestPriority
	statusReason: CodeableConcept
	subject: CommunicationSubject
	instantiatesUri: [String] @search(by: [exact])
	payload: [CommunicationPayload]
	identifier: [Identifier]
	inResponseTo: [Communication]
	reasonCode: [CodeableConcept]
	medium: [CodeableConcept]
	id: String! @id
	note: [Annotation]
	status: EventStatus!
	partOf: [Resource]
	sent: DateTime @search
	category: [CodeableConcept]
	basedOn: [Resource]
	sender: CommunicationSender
	topic: CodeableConcept
	about: [Resource]
	reasonReference: [CommunicationReasonReference]
	instantiatesCanonical: [String]
	encounter: Encounter
	received: DateTime @search
}

type CommunicationRequest {
    recipient: [CommunicationRequestRecipient]
	priority: RequestPriority
	statusReason: CodeableConcept
	subject: CommunicationRequestSubject
	payload: [CommunicationRequestPayload]
	identifier: [Identifier]
	authoredOn: DateTime @search
	requester: CommunicationRequestRequester
	reasonCode: [CodeableConcept]
	medium: [CodeableConcept]
	doNotPerform: Boolean
	id: String! @id
	note: [Annotation]
	status: RequestStatus!
	groupIdentifier: Identifier
	category: [CodeableConcept]
	basedOn: [Resource]
	sender: CommunicationRequestSender
	about: [Resource]
	reasonReference: [CommunicationRequestReasonReference]
	encounter: Encounter
	replaces: [CommunicationRequest]
}

type CommunicationRequestPayload {
    id: String! @id
	contentString: String!
	contentAttachment: Attachment!
	contentReference: Reference!
}

type CommunicationPayload {
    id: String! @id
	contentString: String!
	contentAttachment: Attachment!
	contentReference: Reference!
}

type CompartmentDefinition {
    experimental: Boolean
	name: String! @search(by: [fulltext])
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	purpose: String
	code: CompartmentType!
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	resource: [CompartmentDefinitionResource]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	search: Boolean!
}

type Composition {
    author: [CompositionAuthor]
	subject: Resource
	attester: [CompositionAttester]
	identifier: Identifier
	event: [CompositionEvent]
	relatesTo: [CompositionRelatesTo]
	section: [CompositionSection]
	confidentiality: VConfidentialityClassification
	id: String! @id
	custodian: Organization
	date: DateTime! @search
	status: CompositionStatus!
	category: [CodeableConcept]
	title: String! @search(by: [fulltext])
	type: CodeableConcept!
	encounter: Encounter
}

type CompositionAttester {
    id: String! @id
	mode: CompositionAttestationMode!
	time: DateTime
	party: CompositionAttesterParty
}

type CompositionEvent {
    id: String! @id
	code: [CodeableConcept]
	period: Period
	detail: [Resource]
}

type CompositionRelatesTo {
    id: String! @id
	code: DocumentRelationshipType!
	targetIdentifier: Identifier!
	targetReference: Reference!
}

type CompositionSection {
    author: [CompositionSectionAuthor]
	entry: [Resource]
	text: Narrative
	section: [CompositionSection]
	code: CodeableConcept
	id: String! @id
	orderedBy: CodeableConcept
	focus: Resource
	mode: ListMode
	title: String
	emptyReason: CodeableConcept
}

type ConceptMap {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String @search(by: [fulltext])
	identifier: Identifier
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	purpose: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	title: String @search(by: [fulltext])
	group: [ConceptMapGroup]
}

type ConceptMapElement {
    id: String! @id
	code: String
	display: String
	target: [ConceptMapTarget]
}

type ConceptMapGroup {
    unmapped: ConceptMapUnmapped
	source: String @search(by: [exact])
	targetVersion: String
	element: [ConceptMapElement]
	id: String! @id
	target: String @search(by: [exact])
	sourceVersion: String
}

type ConceptMapTarget {
    equivalence: ConceptMapEquivalence!
	code: String
	id: String! @id
	dependsOn: [ConceptMapDependsOn]
	comment: String
	display: String
	product: [ConceptMapDependsOn]
}

type ConceptMapUnmapped {
    url: String
	code: String
	id: String! @id
	mode: ConceptMapGroupUnmappedMode!
	display: String
}

type Condition {
    stage: [ConditionStage]
	verificationStatus: CodeableConcept
	clinicalStatus: CodeableConcept
	subject: ConditionSubject!
	identifier: [Identifier]
	recordedDate: DateTime @search
	code: CodeableConcept
	id: String! @id
	note: [Annotation]
	evidence: [ConditionEvidence]
	category: [CodeableConcept]
	severity: CodeableConcept
	bodySite: [CodeableConcept]
	encounter: Encounter
	asserter: ConditionAsserter
	recorder: ConditionRecorder
}

type ConditionEvidence {
    id: String! @id
	code: [CodeableConcept]
	detail: [Resource]
}

type ConditionStage {
    id: String! @id
	summary: CodeableConcept
	assessment: [ConditionStageAssessment]
	type: CodeableConcept
}

type Consent {
    organization: [Organization]
	identifier: [Identifier]
	scope: CodeableConcept!
	verification: [ConsentVerification]
	dateTime: DateTime @search
	id: String! @id
	policyRule: CodeableConcept
	status: ConsentState!
	category: [CodeableConcept]
	provision: ConsentProvision
	policy: [ConsentPolicy]
	performer: [ConsentPerformer]
	patient: Patient
}

type ConsentActor {
    id: String! @id
	role: CodeableConcept!
	reference: ConsentActorReference!
}

type ConsentData {
    id: String! @id
	meaning: ConsentDataMeaning!
	reference: Resource!
}

type ConsentProvision {
    actor: [ConsentActor]
	data: [ConsentData]
	securityLabel: [Coding]
	purpose: [Coding]
	code: [CodeableConcept]
	id: String! @id
	class: [Coding]
	provision: [ConsentProvision]
	dataPeriod: Period
	type: ConsentProvisionType
	action: [CodeableConcept]
	period: Period
}

type ConsentVerification {
    id: String! @id
	verified: Boolean!
	verifiedWith: ConsentVerificationVerifiedWith
	verificationDate: DateTime
}

type ContactDetail {
    id: String! @id
	name: String @search(by: [fulltext])
	telecom: [ContactPoint]
}

type ContactPoint {
    system: ContactPointSystem
	rank: Int
	id: String! @id
	use: ContactPointUse
	value: String
	period: Period
}

type Contract {
    subtitle: String
	author: ContractAuthor
	contentDefinition: ContractContentDefinition
	name: String
	supportingInfo: [Resource]
	subject: [Resource]
	instantiatesUri: String @search(by: [exact])
	identifier: [Identifier]
	url: String @search(by: [exact])
	scope: CodeableConcept
	domain: [Location]
	contentDerivative: CodeableConcept
	site: [Location]
	term: [ContractTerm]
	applies: Period
	rule: [ContractRule]
	issued: DateTime @search
	alias: [String]
	version: String
	legal: [ContractLegal]
	id: String! @id
	friendly: [ContractFriendly]
	status: ContractResourceStatusCodes
	signer: [ContractSigner]
	expirationType: CodeableConcept
	title: String
	type: CodeableConcept
	subType: [CodeableConcept]
	instantiatesCanonical: Contract
	relevantHistory: [Provenance]
	legalState: CodeableConcept
	authority: [Organization]
}

type ContractAction {
    occurrenceDateTime: DateTime
	linkId: [String]
	subject: [ContractSubject]
	performerType: [CodeableConcept]
	intent: CodeableConcept!
	context: ContractActionContext
	reasonLinkId: [String]
	requester: [ContractActionRequester]
	contextLinkId: [String]
	requesterLinkId: [String]
	reasonCode: [CodeableConcept]
	reason: [String]
	doNotPerform: Boolean
	id: String! @id
	note: [Annotation]
	occurrencePeriod: Period
	status: CodeableConcept!
	occurrenceTiming: Timing
	securityLabelNumber: [Int]
	performerRole: CodeableConcept
	performerLinkId: [String]
	type: CodeableConcept!
	reasonReference: [ContractActionReasonReference]
	performer: ContractActionPerformer
}

type ContractAnswer {
    valueDecimal: Float!
	valueUri: String!
	valueQuantity: Quantity!
	valueString: String!
	valueBoolean: Boolean!
	valueDate: DateTime!
	valueDateTime: DateTime!
	valueInteger: Int!
	id: String! @id
	valueReference: Reference!
	valueTime: DateTime!
	valueCoding: Coding!
	valueAttachment: Attachment!
}

type ContractAsset {
    linkId: [String]
	subtype: [CodeableConcept]
	scope: CodeableConcept
	typeReference: [Resource]
	context: [ContractContext]
	text: String
	relationship: Coding
	id: String! @id
	condition: String
	securityLabelNumber: [Int]
	answer: [ContractAnswer]
	usePeriod: [Period]
	valuedItem: [ContractValuedItem]
	type: [CodeableConcept]
	periodType: [CodeableConcept]
	period: [Period]
}

type ContractContentDefinition {
    copyright: String
	publicationStatus: ContractResourcePublicationStatusCodes!
	id: String! @id
	publicationDate: DateTime
	publisher: ContractContentDefinitionPublisher
	type: CodeableConcept!
	subType: CodeableConcept
}

type ContractContext {
    id: String! @id
	reference: Resource
	code: [CodeableConcept]
	text: String
}

type ContractFriendly {
    id: String! @id
	contentAttachment: Attachment!
	contentReference: Reference!
}

type ContractLegal {
    id: String! @id
	contentAttachment: Attachment!
	contentReference: Reference!
}

type ContractOffer {
    linkId: [String]
	identifier: [Identifier]
	text: String
	decision: CodeableConcept
	decisionMode: [CodeableConcept]
	id: String! @id
	party: [ContractParty]
	securityLabelNumber: [Int]
	answer: [ContractAnswer]
	topic: Resource
	type: CodeableConcept
}

type ContractParty {
    id: String! @id
	reference: [ContractPartyReference]
	role: CodeableConcept!
}

type ContractRule {
    id: String! @id
	contentAttachment: Attachment!
	contentReference: Reference!
}

type ContractSecurityLabel {
    number: [Int]
	id: String! @id
	category: [Coding]
	control: [Coding]
	classification: Coding!
}

type ContractSigner {
    id: String! @id
	type: Coding!
	party: ContractSignerParty!
	signature: [Signature]
}

type ContractSubject {
    id: String! @id
	reference: [ContractSubjectReference]
	role: CodeableConcept
}

type ContractTerm {
    identifier: Identifier
	securityLabel: [ContractSecurityLabel]
	applies: Period
	text: String
	issued: DateTime
	id: String! @id
	offer: ContractOffer!
	asset: [ContractAsset]
	type: CodeableConcept
	subType: CodeableConcept
	group: [ContractTerm]
	action: [ContractAction]
	topicReference: Reference
	topicCodeableConcept: CodeableConcept
}

type ContractValuedItem {
    entityReference: Reference
	recipient: ContractValuedItemRecipient
	linkId: [String]
	quantity: Quantity
	identifier: Identifier
	responsible: ContractValuedItemResponsible
	effectiveTime: DateTime
	net: Money
	factor: Float
	payment: String
	points: Float
	id: String! @id
	securityLabelNumber: [Int]
	paymentDate: DateTime
	unitPrice: Money
	entityCodeableConcept: CodeableConcept
}

type Contributor {
    id: String! @id
	type: ContributorType!
	name: String!
	contact: [ContactDetail]
}

type Count {
    system: String
	code: String
	id: String! @id
	unit: String
	comparator: QuantityComparator
	value: Float
}

type Coverage {
    payor: [CoveragePayor]
	network: String
	identifier: [Identifier]
	subscriber: CoverageSubscriber
	relationship: CodeableConcept
	id: String! @id
	policyHolder: CoveragePolicyHolder
	order: Int
	status: FinancialResourceStatusCodes!
	subrogation: Boolean
	dependent: String @search(by: [fulltext])
	beneficiary: Patient!
	class: [CoverageClass]
	subscriberId: String
	costToBeneficiary: [CoverageCostToBeneficiary]
	type: CodeableConcept
	period: Period
	contract: [Contract]
}

type CoverageEligibilityRequest {
    supportingInfo: [CoverageEligibilityRequestSupportingInfo]
	priority: CodeableConcept
	provider: CoverageEligibilityRequestProvider
	insurance: [CoverageEligibilityRequestInsurance]
	identifier: [Identifier]
	purpose: [EligibilityRequestPurpose]
	id: String! @id
	status: FinancialResourceStatusCodes!
	facility: Location
	insurer: Organization!
	enterer: CoverageEligibilityRequestEnterer
	created: DateTime! @search
	patient: Patient!
	item: [CoverageEligibilityRequestItem]
}

type CoverageEligibilityRequestDiagnosis {
    id: String! @id
	diagnosisCodeableConcept: CodeableConcept
	diagnosisReference: Reference
}

type CoverageEligibilityRequestInsurance {
    id: String! @id
	focal: Boolean
	coverage: Coverage!
	businessArrangement: String
}

type CoverageEligibilityRequestItem {
    quantity: Quantity
	diagnosis: [CoverageEligibilityRequestDiagnosis]
	provider: CoverageEligibilityRequestItemProvider
	productOrService: CodeableConcept
	id: String! @id
	category: CodeableConcept
	supportingInfoSequence: [Int]
	modifier: [CodeableConcept]
	detail: [Resource]
	unitPrice: Money
	facility: CoverageEligibilityRequestItemFacility
}

type CoverageEligibilityRequestSupportingInfo {
    id: String! @id
	sequence: Int!
	information: Resource!
	appliesToAll: Boolean
}

type CoverageEligibilityResponse {
    requestor: CoverageEligibilityResponseRequestor
	request: CoverageEligibilityRequest!
	insurance: [CoverageEligibilityResponseInsurance]
	identifier: [Identifier]
	disposition: String @search(by: [fulltext])
	outcome: RemittanceOutcome!
	preAuthRef: String
	purpose: [EligibilityResponsePurpose]
	id: String! @id
	error: [CoverageEligibilityResponseError]
	status: FinancialResourceStatusCodes!
	form: CodeableConcept
	insurer: Organization!
	created: DateTime! @search
	patient: Patient!
}

type CoverageEligibilityResponseBenefit {
    allowedUnsignedInt: Int
	usedUnsignedInt: Int
	allowedMoney: Money
	id: String! @id
	usedString: String
	type: CodeableConcept!
	allowedString: String
	usedMoney: Money
}

type CoverageEligibilityResponseError {
    id: String! @id
	code: CodeableConcept!
}

type CoverageEligibilityResponseInsurance {
    benefitPeriod: Period
	coverage: Coverage!
	id: String! @id
	inforce: Boolean
	item: [CoverageEligibilityResponseItem]
}

type CoverageEligibilityResponseItem {
    network: CodeableConcept
	name: String
	provider: CoverageEligibilityResponseItemProvider
	description: String
	authorizationRequired: Boolean
	term: CodeableConcept
	productOrService: CodeableConcept
	authorizationSupporting: [CodeableConcept]
	id: String! @id
	category: CodeableConcept
	authorizationUrl: String
	modifier: [CodeableConcept]
	unit: CodeableConcept
	benefit: [CoverageEligibilityResponseBenefit]
	excluded: Boolean
}

type CoverageClass {
    id: String! @id
	type: CodeableConcept!
	value: String! @search(by: [fulltext])
	name: String
}

type CoverageCostToBeneficiary {
    valueQuantity: Quantity!
	exception: [CoverageException]
	valueMoney: Money!
	id: String! @id
	type: CodeableConcept
}

type CoverageException {
    id: String! @id
	type: CodeableConcept!
	period: Period
}

type DataRequirement {
    dateFilter: [DataRequirementDateFilter_]
	subjectReference: Reference
	mustSupport: [String]
	subjectCodeableConcept: CodeableConcept
	id: String! @id
	profile: [String]
	codeFilter: [DataRequirementCodeFilter_]
	sort: [DataRequirementSort]
	type: String!
	limit: Int
}

type DataRequirementCodeFilter_ {
    valueSet: String
	path: String
	searchParam: String
	code: [Coding]
	id: String! @id
}

type DataRequirementDateFilter_ {
    path: String
	searchParam: String
	valueDateTime: DateTime
	id: String! @id
	valuePeriod: Period
	valueDuration: Duration
}

type DataRequirementSort {
    id: String! @id
	path: String!
	direction: SortDirection!
}

type DetectedIssue {
    reference: String
	implicated: [Resource]
	author: DetectedIssueAuthor
	identifier: [Identifier]
	code: CodeableConcept
	id: String! @id
	status: ObservationStatus!
	evidence: [DetectedIssueEvidence]
	severity: DetectedIssueSeverity
	detail: String
	patient: Patient
	mitigation: [DetectedIssueMitigation]
}

type DetectedIssueEvidence {
    id: String! @id
	code: [CodeableConcept]
	detail: [Resource]
}

type DetectedIssueMitigation {
    id: String! @id
	action: CodeableConcept!
	date: DateTime
	author: DetectedIssueMitigationAuthor
}

type Device {
    deviceName: [DeviceDeviceName]
	parent: Device
	serialNumber: String
	expirationDate: DateTime
	statusReason: [CodeableConcept]
	location: Location
	identifier: [Identifier]
	url: String @search(by: [exact])
	udiCarrier: [DeviceUdiCarrier]
	contact: [ContactPoint]
	partNumber: String
	manufactureDate: DateTime
	modelNumber: String @search(by: [fulltext])
	distinctIdentifier: String
	version: [DeviceVersion]
	id: String! @id
	specialization: [DeviceSpecialization]
	note: [Annotation]
	status: FHIRDeviceStatus
	definition: DeviceDefinition
	property: [DeviceProperty]
	lotNumber: String
	owner: Organization
	manufacturer: String @search(by: [fulltext])
	safety: [CodeableConcept]
	type: CodeableConcept
	patient: Patient
}

type DeviceDefinition {
    deviceName: [DeviceDefinitionDeviceName]
	parentDevice: DeviceDefinition
	quantity: Quantity
	onlineInformation: String
	identifier: [Identifier]
	url: String
	udiDeviceIdentifier: [DeviceDefinitionUdiDeviceIdentifier]
	languageCode: [CodeableConcept]
	contact: [ContactPoint]
	modelNumber: String
	version: [String]
	id: String! @id
	specialization: [DeviceDefinitionSpecialization]
	note: [Annotation]
	physicalCharacteristics: ProdCharacteristic
	capability: [DeviceDefinitionCapability]
	material: [DeviceDefinitionMaterial]
	property: [DeviceDefinitionProperty]
	owner: Organization
	safety: [CodeableConcept]
	type: CodeableConcept
	shelfLifeStorage: [ProductShelfLife]
}

type DeviceDefinitionCapability {
    id: String! @id
	type: CodeableConcept!
	description: [CodeableConcept]
}

type DeviceDefinitionDeviceName {
    id: String! @id
	name: String!
	type: DeviceNameType!
}

type DeviceDefinitionMaterial {
    id: String! @id
	substance: CodeableConcept!
	alternate: Boolean
	allergenicIndicator: Boolean
}

type DeviceDefinitionProperty {
    id: String! @id
	type: CodeableConcept!
	valueQuantity: [Quantity]
	valueCode: [CodeableConcept]
}

type DeviceMetric {
    parent: Device
	calibration: [DeviceMetricCalibration]
	source: Device
	identifier: [Identifier]
	measurementPeriod: Timing
	operationalStatus: DeviceMetricOperationalStatus
	color: DeviceMetricColor
	id: String! @id
	category: DeviceMetricCategory!
	unit: CodeableConcept
	type: CodeableConcept!
}

type DeviceMetricCalibration {
    id: String! @id
	type: DeviceMetricCalibrationType
	state: DeviceMetricCalibrationState
	time: DateTime
}

type DeviceRequest {
    supportingInfo: [Resource]
	parameter: [DeviceRequestParameter]
	priority: RequestPriority
	subject: DeviceRequestSubject!
	performerType: CodeableConcept
	instantiatesUri: [String] @search(by: [exact])
	insurance: [DeviceRequestInsurance]
	identifier: [Identifier]
	intent: RequestIntent!
	authoredOn: DateTime @search
	priorRequest: [Resource]
	requester: DeviceRequestRequester
	reasonCode: [CodeableConcept]
	id: String! @id
	note: [Annotation]
	status: RequestStatus
	groupIdentifier: Identifier
	basedOn: [Resource]
	reasonReference: [DeviceRequestReasonReference]
	instantiatesCanonical: [String]
	relevantHistory: [Provenance]
	encounter: Encounter
	performer: DeviceRequestPerformer
}

type DeviceRequestParameter {
    valueQuantity: Quantity
	valueBoolean: Boolean
	code: CodeableConcept
	valueRange: Range
	id: String! @id
	valueCodeableConcept: CodeableConcept
}

type DeviceUseStatement {
    source: DeviceUseStatementSource
	subject: DeviceUseStatementSubject!
	identifier: [Identifier]
	derivedFrom: [DeviceUseStatementDerivedFrom]
	reasonCode: [CodeableConcept]
	id: String! @id
	recordedOn: DateTime
	note: [Annotation]
	status: DeviceUseStatementStatus!
	basedOn: [ServiceRequest]
	bodySite: CodeableConcept
	reasonReference: [DeviceUseStatementReasonReference]
	device: Device!
}

type DeviceDeviceName {
    id: String! @id
	name: String! @search(by: [fulltext])
	type: DeviceNameType!
}

type DeviceProperty {
    id: String! @id
	type: CodeableConcept!
	valueQuantity: [Quantity]
	valueCode: [CodeableConcept]
}

type DeviceSpecialization {
    id: String! @id
	systemType: CodeableConcept!
	version: String
}

type DeviceUdiCarrier {
    jurisdiction: String
	carrierAIDC: String
	deviceIdentifier: String @search(by: [fulltext])
	carrierHRF: String @search(by: [fulltext])
	issuer: String
	id: String! @id
	entryType: UDIEntryType
}

type DeviceVersion {
    id: String! @id
	type: CodeableConcept
	component: Identifier
	value: String!
}

type DiagnosticReport {
    imagingStudy: [ImagingStudy]
	subject: DiagnosticReportSubject
	identifier: [Identifier]
	presentedForm: [Attachment]
	result: [Observation]
	resultsInterpreter: [DiagnosticReportResultsInterpreter]
	conclusion: String
	code: CodeableConcept!
	issued: DateTime @search
	id: String! @id
	conclusionCode: [CodeableConcept]
	status: DiagnosticReportStatus!
	media: [DiagnosticReportMedia]
	category: [CodeableConcept]
	basedOn: [DiagnosticReportBasedOn]
	specimen: [Specimen]
	encounter: Encounter
	performer: [DiagnosticReportPerformer]
}

type DiagnosticReportMedia {
    id: String! @id
	comment: String
	link: Media!
}

type Distance {
    system: String
	code: String
	id: String! @id
	unit: String
	comparator: QuantityComparator
	value: Float
}

type DocumentManifest {
    recipient: [DocumentManifestRecipient]
	author: [DocumentManifestAuthor]
	source: String @search(by: [exact])
	subject: DocumentManifestSubject
	identifier: [Identifier]
	description: String @search(by: [fulltext])
	masterIdentifier: Identifier
	id: String! @id
	related: [DocumentManifestRelated]
	status: DocumentReferenceStatus!
	content: [Resource]
	type: CodeableConcept
	created: DateTime @search
}

type DocumentManifestRelated {
    id: String! @id
	identifier: Identifier
	ref: Resource
}

type DocumentReference {
    author: [DocumentReferenceAuthor]
	authenticator: DocumentReferenceAuthenticator
	subject: DocumentReferenceSubject
	identifier: [Identifier]
	description: String @search(by: [fulltext])
	context: DocumentReferenceContext
	securityLabel: [CodeableConcept]
	docStatus: CompositionStatus
	relatesTo: [DocumentReferenceRelatesTo]
	masterIdentifier: Identifier
	id: String! @id
	custodian: Organization
	date: DateTime @search
	status: DocumentReferenceStatus!
	content: [DocumentReferenceContent]
	category: [CodeableConcept]
	type: CodeableConcept
}

type DocumentReferenceContent {
    id: String! @id
	attachment: Attachment!
	format: Coding
}

type DocumentReferenceContext {
    event: [CodeableConcept]
	practiceSetting: CodeableConcept
	sourcePatientInfo: Patient
	id: String! @id
	related: [Resource]
	facilityType: CodeableConcept
	encounter: [DocumentReferenceContextEncounter]
	period: Period
}

type DocumentReferenceRelatesTo {
    id: String! @id
	code: DocumentRelationshipType!
	target: DocumentReference!
}

type DomainResource {
    text: Narrative
	id: String! @id
	modifierExtension: [Extension]
	contained: [ResourceContainer]
	extension: [Extension]
}

type Dosage {
    asNeededBoolean: Boolean
	method: CodeableConcept
	maxDosePerAdministration: Quantity
	maxDosePerLifetime: Quantity
	additionalInstruction: [CodeableConcept]
	site: CodeableConcept
	text: String
	doseAndRate: [DosageDoseAndRate]
	timing: Timing
	id: String! @id
	sequence: Int
	patientInstruction: String
	asNeededCodeableConcept: CodeableConcept
	maxDosePerPeriod: Ratio
	route: CodeableConcept
}

type DosageDoseAndRate {
    doseRange: Range
	rateRange: Range
	doseQuantity: Quantity
	rateRatio: Ratio
	rateQuantity: Quantity
	id: String! @id
	type: CodeableConcept
}

type Duration {
    system: String
	code: String
	id: String! @id
	unit: String
	comparator: QuantityComparator
	value: Float
}

type EffectEvidenceSynthesis {
    copyright: String
	jurisdiction: [CodeableConcept]
	author: [ContactDetail]
	synthesisType: CodeableConcept
	name: String @search(by: [fulltext])
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	population: EvidenceVariable!
	effectivePeriod: Period
	certainty: [EffectEvidenceSynthesisCertainty]
	endorser: [ContactDetail]
	exposureAlternative: EvidenceVariable!
	outcome: EvidenceVariable!
	contact: [ContactDetail]
	exposure: EvidenceVariable!
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	resultsByExposure: [EffectEvidenceSynthesisResultsByExposure]
	id: String! @id
	date: DateTime @search
	note: [Annotation]
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	studyType: CodeableConcept
	sampleSize: EffectEvidenceSynthesisSampleSize
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	effectEstimate: [EffectEvidenceSynthesisEffectEstimate]
}

type EffectEvidenceSynthesisCertainty {
    id: String! @id
	rating: [CodeableConcept]
	note: [Annotation]
	certaintySubcomponent: [EffectEvidenceSynthesisCertaintySubcomponent]
}

type EffectEvidenceSynthesisCertaintySubcomponent {
    id: String! @id
	type: CodeableConcept
	rating: [CodeableConcept]
	note: [Annotation]
}

type EffectEvidenceSynthesisEffectEstimate {
    precisionEstimate: [EffectEvidenceSynthesisPrecisionEstimate]
	description: String
	id: String! @id
	type: CodeableConcept
	unitOfMeasure: CodeableConcept
	value: Float
	variantState: CodeableConcept
}

type EffectEvidenceSynthesisPrecisionEstimate {
    to: Float
	id: String! @id
	from: Float
	type: CodeableConcept
	level: Float
}

type EffectEvidenceSynthesisResultsByExposure {
    description: String
	riskEvidenceSynthesis: RiskEvidenceSynthesis!
	id: String! @id
	exposureState: ExposureState
	variantState: CodeableConcept
}

type ElementDefinition {
    fixedOid: String
	defaultValueTiming: Timing
	maxValueDateTime: DateTime
	fixedRelatedArtifact: RelatedArtifact
	patternUsageContext: UsageContext
	defaultValueUuid: String
	fixedUsageContext: UsageContext
	patternPositiveInt: Int
	patternMarkdown: String
	defaultValueInteger: Int
	defaultValueUnsignedInt: Int
	patternContactDetail: ContactDetail
	patternAttachment: Attachment
	patternPeriod: Period
	fixedDataRequirement: DataRequirement
	defaultValueCanonical: String
	maxValueInstant: DateTime
	patternCode: String
	fixedInteger: Int
	patternUnsignedInt: Int
	defaultValueDistance: Distance
	fixedPositiveInt: Int
	binding: ElementDefinitionBinding
	patternRelatedArtifact: RelatedArtifact
	patternTime: DateTime
	fixedCode: String
	defaultValueAge: Age
	path: String!
	defaultValueUri: String
	patternBoolean: Boolean
	patternTiming: Timing
	patternCount: Count
	fixedInstant: DateTime
	fixedAddress: Address
	defaultValueExpression: Expression
	defaultValueContactDetail: ContactDetail
	patternAge: Age
	patternExpression: Expression
	patternHumanName: HumanName
	maxValueUnsignedInt: Int
	minValueDateTime: DateTime
	maxValueDecimal: Float
	fixedHumanName: HumanName
	defaultValueSignature: Signature
	fixedAge: Age
	patternRange: Range
	patternInstant: DateTime
	fixedMoney: Money
	short: String
	defaultValuePositiveInt: Int
	fixedDateTime: DateTime
	fixedDosage: Dosage
	fixedIdentifier: Identifier
	patternSignature: Signature
	contentReference: String
	fixedContactDetail: ContactDetail
	fixedString: String
	patternUuid: String
	isSummary: Boolean
	fixedTime: DateTime
	patternReference: Reference
	patternMoney: Money
	fixedSampledData: SampledData
	mustSupport: Boolean
	patternDecimal: Float
	minValueQuantity: Quantity
	defaultValueRatio: Ratio
	label: String
	fixedTriggerDefinition: TriggerDefinition
	fixedRange: Range
	patternAddress: Address
	slicing: ElementDefinitionSlicing
	defaultValueUsageContext: UsageContext
	min: Int
	patternAnnotation: Annotation
	mapping: [ElementDefinitionMapping]
	patternDuration: Duration
	fixedQuantity: Quantity
	patternString: String
	defaultValueQuantity: Quantity
	maxValueTime: DateTime
	fixedParameterDefinition: ParameterDefinition
	patternBase64Binary: String
	defaultValueDuration: Duration
	fixedCoding: Coding
	defaultValueMarkdown: String
	sliceIsConstraining: Boolean
	defaultValueDate: DateTime
	minValueInstant: DateTime
	fixedId: String
	maxValueDate: DateTime
	fixedExpression: Expression
	fixedCanonical: String
	defaultValueCount: Count
	isModifierReason: String
	defaultValuePeriod: Period
	isModifier: Boolean
	defaultValueContactPoint: ContactPoint
	base: ElementDefinitionBase
	defaultValueCoding: Coding
	code: [Coding]
	patternCanonical: String
	defaultValueCode: String
	patternIdentifier: Identifier
	maxValuePositiveInt: Int
	patternCoding: Coding
	fixedUuid: String
	fixedSignature: Signature
	alias: [String]
	defaultValueMoney: Money
	patternDate: DateTime
	maxValueQuantity: Quantity
	defaultValueHumanName: HumanName
	fixedUrl: String
	id: String! @id
	fixedRatio: Ratio
	defaultValueTriggerDefinition: TriggerDefinition
	condition: [String]
	defaultValueAddress: Address
	max: String
	fixedUri: String
	fixedTiming: Timing
	fixedCodeableConcept: CodeableConcept
	defaultValueOid: String
	fixedMarkdown: String
	defaultValueDateTime: DateTime
	patternOid: String
	patternDistance: Distance
	patternUrl: String
	defaultValueMeta: Meta
	defaultValueRelatedArtifact: RelatedArtifact
	fixedUnsignedInt: Int
	defaultValueBoolean: Boolean
	patternContributor: Contributor
	comment: String
	defaultValueIdentifier: Identifier
	requirements: String
	minValueUnsignedInt: Int
	fixedAttachment: Attachment
	defaultValueContributor: Contributor
	fixedContactPoint: ContactPoint
	defaultValueUrl: String
	fixedReference: Reference
	patternCodeableConcept: CodeableConcept
	fixedPeriod: Period
	defaultValueTime: DateTime
	minValueDecimal: Float
	patternTriggerDefinition: TriggerDefinition
	defaultValueDataRequirement: DataRequirement
	definition: String
	defaultValueInstant: DateTime
	maxValueInteger: Int
	defaultValueDecimal: Float
	fixedMeta: Meta
	constraint: [ElementDefinitionConstraint]
	fixedCount: Count
	patternUri: String
	orderMeaning: String
	patternDataRequirement: DataRequirement
	fixedAnnotation: Annotation
	fixedBase64Binary: String
	patternDateTime: DateTime
	defaultValueId: String
	minValueDate: DateTime
	defaultValueAnnotation: Annotation
	defaultValueCodeableConcept: CodeableConcept
	fixedDuration: Duration
	patternSampledData: SampledData
	type: [ElementDefinitionType]
	patternParameterDefinition: ParameterDefinition
	fixedDate: DateTime
	minValuePositiveInt: Int
	patternDosage: Dosage
	sliceName: String
	patternContactPoint: ContactPoint
	example: [ElementDefinitionExample]
	patternId: String
	minValueInteger: Int
	patternRatio: Ratio
	defaultValueString: String
	patternMeta: Meta
	defaultValueReference: Reference
	fixedContributor: Contributor
	defaultValueBase64Binary: String
	patternQuantity: Quantity
	fixedBoolean: Boolean
	fixedDistance: Distance
	maxLength: Int
	defaultValueAttachment: Attachment
	defaultValueRange: Range
	patternInteger: Int
	representation: [PropertyRepresentation]
	defaultValueSampledData: SampledData
	minValueTime: DateTime
	defaultValueDosage: Dosage
	meaningWhenMissing: String
	fixedDecimal: Float
	defaultValueParameterDefinition: ParameterDefinition
}

type ElementDefinitionBinding {
    id: String! @id
	strength: BindingStrength!
	description: String
	valueSet: String
}

type ElementDefinitionConstraint {
    source: String
	human: String!
	key: String!
	id: String! @id
	expression: String
	xpath: String
	requirements: String
	severity: ConstraintSeverity!
}

type ElementDefinitionDiscriminator {
    id: String! @id
	type: DiscriminatorType!
	path: String!
}

type ElementDefinitionExample {
    valueDecimal: Float!
	valueHumanName: HumanName!
	valueCode: String!
	valueDosage: Dosage!
	valueMarkdown: String!
	valueUri: String!
	valueContactDetail: ContactDetail!
	valueAge: Age!
	valueUsageContext: UsageContext!
	valueQuantity: Quantity!
	valueDataRequirement: DataRequirement!
	valueCount: Count!
	valueString: String!
	label: String!
	valueBoolean: Boolean!
	valueIdentifier: Identifier!
	valueDistance: Distance!
	valueMoney: Money!
	valueDate: DateTime!
	valueRange: Range!
	valueDateTime: DateTime!
	valueId: String!
	valueUnsignedInt: Int!
	valueMeta: Meta!
	valueInteger: Int!
	id: String! @id
	valuePositiveInt: Int!
	valueParameterDefinition: ParameterDefinition!
	valuePeriod: Period!
	valueReference: Reference!
	valueContactPoint: ContactPoint!
	valueTime: DateTime!
	valueTriggerDefinition: TriggerDefinition!
	valueUuid: String!
	valueRelatedArtifact: RelatedArtifact!
	valueInstant: DateTime!
	valueExpression: Expression!
	valueBase64Binary: String!
	valueOid: String!
	valueSampledData: SampledData!
	valueContributor: Contributor!
	valueCoding: Coding!
	valueUrl: String!
	valueRatio: Ratio!
	valueDuration: Duration!
	valueCanonical: String!
	valueCodeableConcept: CodeableConcept!
	valueAnnotation: Annotation!
	valueAttachment: Attachment!
	valueAddress: Address!
	valueTiming: Timing!
	valueSignature: Signature!
}

type ElementDefinitionSlicing {
    description: String
	discriminator: [ElementDefinitionDiscriminator]
	ordered: Boolean
	id: String! @id
	rules: SlicingRules!
}

type ElementDefinitionType {
    targetProfile: [String]
	versioning: ReferenceVersionRules
	code: String!
	id: String! @id
	profile: [String]
	aggregation: [AggregationMode]
}

type Encounter {
    participant: [EncounterParticipant]
	serviceType: CodeableConcept
	priority: CodeableConcept
	diagnosis: [EncounterDiagnosis]
	location: [EncounterLocation]
	subject: EncounterSubject
	identifier: [Identifier]
	episodeOfCare: [EpisodeOfCare]
	statusHistory: [EncounterStatusHistory]
	reasonCode: [CodeableConcept]
	serviceProvider: Organization
	id: String! @id
	status: EncounterStatus!
	partOf: Encounter
	hospitalization: EncounterHospitalization
	basedOn: [ServiceRequest]
	class: Coding!
	length: Duration
	account: [Account]
	type: [CodeableConcept]
	appointment: [Appointment]
	reasonReference: [EncounterReasonReference]
	classHistory: [EncounterClassHistory]
	period: Period
}

type EncounterClassHistory {
    id: String! @id
	class: Coding!
	period: Period!
}

type EncounterDiagnosis {
    id: String! @id
	condition: EncounterDiagnosisCondition!
	use: CodeableConcept
	rank: Int
}

type EncounterHospitalization {
    dischargeDisposition: CodeableConcept
	specialCourtesy: [CodeableConcept]
	reAdmission: CodeableConcept
	dietPreference: [CodeableConcept]
	id: String! @id
	admitSource: CodeableConcept
	origin: EncounterHospitalizationOrigin
	specialArrangement: [CodeableConcept]
	preAdmissionIdentifier: Identifier
	destination: EncounterHospitalizationDestination
}

type EncounterLocation {
    physicalType: CodeableConcept
	location: Location!
	id: String! @id
	status: EncounterLocationStatus
	period: Period
}

type EncounterParticipant {
    id: String! @id
	type: [CodeableConcept]
	period: Period
	individual: EncounterParticipantIndividual
}

type EncounterStatusHistory {
    id: String! @id
	status: EncounterStatus!
	period: Period!
}

type Endpoint {
    name: String @search(by: [fulltext])
	payloadMimeType: [String]
	identifier: [Identifier]
	contact: [ContactPoint]
	payloadType: [CodeableConcept]
	id: String! @id
	status: EndpointStatus!
	address: String!
	header: [String]
	managingOrganization: Organization
	period: Period
	connectionType: Coding!
}

type EnrollmentRequest {
    provider: EnrollmentRequestProvider
	identifier: [Identifier]
	coverage: Coverage
	id: String! @id
	status: FinancialResourceStatusCodes
	insurer: Organization
	candidate: Patient
	created: DateTime
}

type EnrollmentResponse {
    organization: Organization
	request: EnrollmentRequest
	identifier: [Identifier]
	disposition: String
	outcome: RemittanceOutcome
	id: String! @id
	status: FinancialResourceStatusCodes
	requestProvider: EnrollmentResponseRequestProvider
	created: DateTime
}

type EpisodeOfCare {
    careManager: EpisodeOfCareCareManager
	referralRequest: [ServiceRequest]
	diagnosis: [EpisodeOfCareDiagnosis]
	identifier: [Identifier]
	statusHistory: [EpisodeOfCareStatusHistory]
	id: String! @id
	status: EpisodeOfCareStatus!
	team: [CareTeam]
	account: [Account]
	type: [CodeableConcept]
	managingOrganization: Organization
	period: Period
	patient: Patient!
}

type EpisodeOfCareDiagnosis {
    id: String! @id
	condition: Condition!
	role: CodeableConcept
	rank: Int
}

type EpisodeOfCareStatusHistory {
    id: String! @id
	status: EpisodeOfCareStatus!
	period: Period!
}

type EventDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	effectivePeriod: Period
	endorser: [ContactDetail]
	contact: [ContactDetail]
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	trigger: [TriggerDefinition]
}

type Evidence {
    copyright: String
	jurisdiction: [CodeableConcept]
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	shortTitle: String
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	exposureVariant: [EvidenceVariable]
	effectivePeriod: Period
	endorser: [ContactDetail]
	outcome: [EvidenceVariable]
	contact: [ContactDetail]
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	exposureBackground: EvidenceVariable!
	date: DateTime @search
	note: [Annotation]
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
}

type EvidenceVariable {
    copyright: String
	jurisdiction: [CodeableConcept]
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	shortTitle: String
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	effectivePeriod: Period
	endorser: [ContactDetail]
	contact: [ContactDetail]
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	note: [Annotation]
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	characteristic: [EvidenceVariableCharacteristic]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	type: EvidenceVariableType
}

type EvidenceVariableCharacteristic {
    usageContext: [UsageContext]
	definitionExpression: Expression!
	groupMeasure: GroupMeasure
	participantEffectiveDateTime: DateTime
	timeFromStart: Duration
	description: String
	participantEffectiveTiming: Timing
	definitionDataRequirement: DataRequirement!
	participantEffectiveDuration: Duration
	definitionTriggerDefinition: TriggerDefinition!
	id: String! @id
	definitionReference: EvidenceVariableCharacteristicDefinitionReference!
	participantEffectivePeriod: Period
	definitionCanonical: String!
	exclude: Boolean
	definitionCodeableConcept: CodeableConcept!
}

type ExampleScenario {
    copyright: String
	jurisdiction: [CodeableConcept]
	actor: [ExampleScenarioActor]
	experimental: Boolean
	name: String @search(by: [fulltext])
	workflow: [String]
	identifier: [Identifier]
	url: String @search(by: [exact])
	process: [ExampleScenarioProcess]
	instance: [ExampleScenarioInstance]
	contact: [ContactDetail]
	purpose: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
}

type ExampleScenarioActor {
    name: String
	description: String
	actorId: String!
	id: String! @id
	type: ExampleScenarioActorType!
}

type ExampleScenarioAlternative {
    id: String! @id
	title: String!
	description: String
	step: [ExampleScenarioStep]
}

type ExampleScenarioInstance {
    resourceId: String!
	name: String
	description: String
	resourceType: ResourceType!
	version: [ExampleScenarioVersion]
	id: String! @id
	containedInstance: [ExampleScenarioContainedInstance]
}

type ExampleScenarioOperation {
    number: String!
	name: String
	request: ExampleScenarioContainedInstance
	receiverActive: Boolean
	description: String
	receiver: String
	response: ExampleScenarioContainedInstance
	id: String! @id
	type: String
	initiatorActive: Boolean
	initiator: String
}

type ExampleScenarioProcess {
    step: [ExampleScenarioStep]
	description: String
	postConditions: String
	id: String! @id
	preConditions: String
	title: String!
}

type ExampleScenarioStep {
    process: [ExampleScenarioProcess]
	pause: Boolean
	alternative: [ExampleScenarioAlternative]
	id: String! @id
	operation: ExampleScenarioOperation
}

type ExplanationOfBenefit {
    accident: ExplanationOfBenefitAccident
	claimResponse: ClaimResponse
	originalPrescription: MedicationRequest
	benefitPeriod: Period
	supportingInfo: [ExplanationOfBenefitSupportingInfo]
	priority: CodeableConcept
	claim: Claim
	diagnosis: [ExplanationOfBenefitDiagnosis]
	provider: ExplanationOfBenefitProvider!
	preAuthRefPeriod: [Period]
	insurance: [ExplanationOfBenefitInsurance]
	identifier: [Identifier]
	prescription: ExplanationOfBenefitPrescription
	benefitBalance: [ExplanationOfBenefitBenefitBalance]
	disposition: String @search(by: [fulltext])
	outcome: ClaimProcessingCodes!
	procedure: [ExplanationOfBenefitProcedure]
	total: [ExplanationOfBenefitTotal]
	preAuthRef: [String]
	payment: ExplanationOfBenefitPayment
	fundsReserveRequested: CodeableConcept
	referral: ServiceRequest
	id: String! @id
	related: [ExplanationOfBenefitRelated]
	processNote: [ExplanationOfBenefitProcessNote]
	formCode: CodeableConcept
	billablePeriod: Period
	status: ExplanationOfBenefitStatus!
	use: Use!
	precedence: Int
	addItem: [ExplanationOfBenefitAddItem]
	type: CodeableConcept!
	form: Attachment
	facility: Location
	subType: CodeableConcept
	insurer: Organization!
	adjudication: [ExplanationOfBenefitAdjudication]
	enterer: ExplanationOfBenefitEnterer
	fundsReserve: CodeableConcept
	careTeam: [ExplanationOfBenefitCareTeam]
	payee: ExplanationOfBenefitPayee
	created: DateTime! @search
	patient: Patient!
	item: [ExplanationOfBenefitItem]
}

type ExplanationOfBenefitAccident {
    locationReference: Reference
	locationAddress: Address
	id: String! @id
	date: DateTime
	type: CodeableConcept
}

type ExplanationOfBenefitAddItem {
    quantity: Quantity
	locationReference: Reference
	provider: [ExplanationOfBenefitAddItemProvider]
	subSite: [CodeableConcept]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	locationAddress: Address
	itemSequence: [Int]
	id: String! @id
	servicedPeriod: Period
	detailSequence: [Int]
	modifier: [CodeableConcept]
	detail: [ExplanationOfBenefitDetail1]
	servicedDate: DateTime
	unitPrice: Money
	noteNumber: [Int]
	bodySite: CodeableConcept
	adjudication: [ExplanationOfBenefitAdjudication]
	subDetailSequence: [Int]
	locationCodeableConcept: CodeableConcept
}

type ExplanationOfBenefitAdjudication {
    reason: CodeableConcept
	amount: Money
	id: String! @id
	category: CodeableConcept!
	value: Float
}

type ExplanationOfBenefitBenefitBalance {
    network: CodeableConcept
	name: String
	description: String
	term: CodeableConcept
	id: String! @id
	category: CodeableConcept!
	financial: [ExplanationOfBenefitFinancial]
	unit: CodeableConcept
	excluded: Boolean
}

type ExplanationOfBenefitCareTeam {
    provider: ExplanationOfBenefitCareTeamProvider!
	qualification: CodeableConcept
	role: CodeableConcept
	responsible: Boolean
	id: String! @id
	sequence: Int!
}

type ExplanationOfBenefitDetail {
    quantity: Quantity
	subDetail: [ExplanationOfBenefitSubDetail]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	sequence: Int!
	revenue: CodeableConcept
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ExplanationOfBenefitAdjudication]
}

type ExplanationOfBenefitDetail1 {
    quantity: Quantity
	subDetail: [ExplanationOfBenefitSubDetail1]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ExplanationOfBenefitAdjudication]
}

type ExplanationOfBenefitDiagnosis {
    packageCode: CodeableConcept
	diagnosisReference: Reference!
	diagnosisCodeableConcept: CodeableConcept!
	onAdmission: CodeableConcept
	id: String! @id
	sequence: Int!
	type: [CodeableConcept]
}

type ExplanationOfBenefitFinancial {
    allowedUnsignedInt: Int
	usedUnsignedInt: Int
	allowedMoney: Money
	id: String! @id
	type: CodeableConcept!
	allowedString: String
	usedMoney: Money
}

type ExplanationOfBenefitInsurance {
    id: String! @id
	focal: Boolean!
	coverage: Coverage!
	preAuthRef: [String]
}

type ExplanationOfBenefitItem {
    quantity: Quantity
	locationReference: Reference
	procedureSequence: [Int]
	careTeamSequence: [Int]
	subSite: [CodeableConcept]
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	locationAddress: Address
	id: String! @id
	sequence: Int!
	servicedPeriod: Period
	revenue: CodeableConcept
	informationSequence: [Int]
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	detail: [ExplanationOfBenefitDetail]
	servicedDate: DateTime
	unitPrice: Money
	noteNumber: [Int]
	bodySite: CodeableConcept
	diagnosisSequence: [Int]
	adjudication: [ExplanationOfBenefitAdjudication]
	encounter: [Encounter]
	locationCodeableConcept: CodeableConcept
}

type ExplanationOfBenefitPayee {
    id: String! @id
	type: CodeableConcept
	party: ExplanationOfBenefitPayeeParty
}

type ExplanationOfBenefitPayment {
    identifier: Identifier
	adjustment: Money
	amount: Money
	id: String! @id
	date: DateTime
	type: CodeableConcept
	adjustmentReason: CodeableConcept
}

type ExplanationOfBenefitProcedure {
    procedureCodeableConcept: CodeableConcept!
	id: String! @id
	sequence: Int!
	date: DateTime
	procedureReference: Reference!
	udi: [Device]
	type: [CodeableConcept]
}

type ExplanationOfBenefitProcessNote {
    number: Int
	text: String
	id: String! @id
	language: CodeableConcept
	type: NoteType
}

type ExplanationOfBenefitRelated {
    id: String! @id
	claim: Claim
	relationship: CodeableConcept
	reference: Identifier
}

type ExplanationOfBenefitSubDetail {
    quantity: Quantity
	programCode: [CodeableConcept]
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	sequence: Int!
	revenue: CodeableConcept
	category: CodeableConcept
	udi: [Device]
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ExplanationOfBenefitAdjudication]
}

type ExplanationOfBenefitSubDetail1 {
    quantity: Quantity
	productOrService: CodeableConcept!
	net: Money
	factor: Float
	id: String! @id
	modifier: [CodeableConcept]
	unitPrice: Money
	noteNumber: [Int]
	adjudication: [ExplanationOfBenefitAdjudication]
}

type ExplanationOfBenefitSupportingInfo {
    timingPeriod: Period
	valueQuantity: Quantity
	valueString: String
	valueBoolean: Boolean
	reason: Coding
	code: CodeableConcept
	id: String! @id
	sequence: Int!
	valueReference: Reference
	timingDate: DateTime
	category: CodeableConcept!
	valueAttachment: Attachment
}

type ExplanationOfBenefitTotal {
    id: String! @id
	category: CodeableConcept!
	amount: Money!
}

type Expression {
    reference: String
	name: String
	description: String
	id: String! @id
	language: ExpressionLanguage!
	expression: String
}

type Extension {
    valueDecimal: Float
	valueHumanName: HumanName
	valueCode: String
	valueDosage: Dosage
	valueMarkdown: String
	valueUri: String
	valueContactDetail: ContactDetail
	valueAge: Age
	valueUsageContext: UsageContext
	valueQuantity: Quantity
	valueDataRequirement: DataRequirement
	valueCount: Count
	valueString: String
	valueBoolean: Boolean
	valueIdentifier: Identifier
	valueDistance: Distance
	valueMoney: Money
	valueDate: DateTime
	valueRange: Range
	valueDateTime: DateTime
	valueId: String
	valueUnsignedInt: Int
	valueMeta: Meta
	valueInteger: Int
	id: String! @id
	valuePositiveInt: Int
	valueParameterDefinition: ParameterDefinition
	valuePeriod: Period
	valueReference: Reference
	valueContactPoint: ContactPoint
	valueTime: DateTime
	valueTriggerDefinition: TriggerDefinition
	valueUuid: String
	valueRelatedArtifact: RelatedArtifact
	valueInstant: DateTime
	valueExpression: Expression
	valueBase64Binary: String
	valueOid: String
	valueSampledData: SampledData
	valueContributor: Contributor
	valueCoding: Coding
	valueUrl: String
	valueRatio: Ratio
	valueDuration: Duration
	valueCanonical: String
	valueCodeableConcept: CodeableConcept
	valueAnnotation: Annotation
	valueAttachment: Attachment
	valueAddress: Address
	valueTiming: Timing
	valueSignature: Signature
}

type FamilyMemberHistory {
    name: String
	estimatedAge: Boolean
	instantiatesUri: [String] @search(by: [exact])
	identifier: [Identifier]
	reasonCode: [CodeableConcept]
	sex: CodeableConcept
	relationship: CodeableConcept!
	id: String! @id
	condition: [FamilyMemberHistoryCondition]
	date: DateTime @search
	note: [Annotation]
	status: FamilyHistoryStatus!
	dataAbsentReason: CodeableConcept
	reasonReference: [FamilyMemberHistoryReasonReference]
	instantiatesCanonical: [String]
	patient: Patient!
}

type FamilyMemberHistoryCondition {
    onsetPeriod: Period
	onsetRange: Range
	contributedToDeath: Boolean
	outcome: CodeableConcept
	onsetAge: Age
	code: CodeableConcept!
	id: String! @id
	note: [Annotation]
	onsetString: String
}

type Flag {
    author: FlagAuthor
	subject: FlagSubject!
	identifier: [Identifier]
	code: CodeableConcept!
	id: String! @id
	status: FlagStatus!
	category: [CodeableConcept]
	encounter: Encounter
	period: Period
}

type Goal {
    achievementStatus: CodeableConcept
	priority: CodeableConcept
	statusReason: String
	subject: GoalSubject!
	identifier: [Identifier]
	description: CodeableConcept!
	outcomeReference: [Observation]
	statusDate: DateTime
	expressedBy: GoalExpressedBy
	id: String! @id
	outcomeCode: [CodeableConcept]
	note: [Annotation]
	category: [CodeableConcept]
	target: [GoalTarget]
	lifecycleStatus: GoalLifecycleStatus!
	addresses: [GoalAddresses]
}

type GoalTarget {
    measure: CodeableConcept
	detailRange: Range
	detailString: String
	detailQuantity: Quantity
	detailBoolean: Boolean
	detailInteger: Int
	detailCodeableConcept: CodeableConcept
	detailRatio: Ratio
	id: String! @id
	dueDate: DateTime
	dueDuration: Duration
}

type GraphDefinition {
    jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String! @search(by: [fulltext])
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	purpose: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	profile: String
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	link: [GraphDefinitionLink]
	start: String! @search(by: [exact])
}

type GraphDefinitionCompartment {
    description: String
	rule: GraphCompartmentRule!
	code: CompartmentType!
	id: String! @id
	expression: String
	use: GraphCompartmentUse!
}

type GraphDefinitionLink {
    path: String
	description: String
	min: Int
	id: String! @id
	max: String
	target: [GraphDefinitionTarget]
	sliceName: String
}

type GraphDefinitionTarget {
    params: String
	id: String! @id
	profile: String
	link: [GraphDefinitionLink]
	type: String!
	compartment: [GraphDefinitionCompartment]
}

type Group {
    name: String
	quantity: Int
	identifier: [Identifier]
	code: CodeableConcept
	id: String! @id
	member: [GroupMember]
	characteristic: [GroupCharacteristic]
	managingEntity: GroupManagingEntity
	type: GroupType!
	actual: Boolean! @search
	active: Boolean
}

type GroupCharacteristic {
    valueQuantity: Quantity!
	valueBoolean: Boolean!
	code: CodeableConcept!
	valueRange: Range!
	id: String! @id
	valueReference: Reference!
	exclude: Boolean! @search
	valueCodeableConcept: CodeableConcept!
	period: Period
}

type GroupMember {
    id: String! @id
	entity: GroupMemberEntity!
	period: Period
	inactive: Boolean
}

type GuidanceResponse {
    occurrenceDateTime: DateTime
	subject: GuidanceResponseSubject
	identifier: [Identifier]
	result: GuidanceResponseResult
	evaluationMessage: [OperationOutcome]
	requestIdentifier: Identifier
	reasonCode: [CodeableConcept]
	id: String! @id
	note: [Annotation]
	status: GuidanceResponseStatus!
	outputParameters: Parameters
	reasonReference: [GuidanceResponseReasonReference]
	encounter: Encounter
	dataRequirement: [DataRequirement]
	performer: Device
}

type HealthcareService {
    program: [CodeableConcept]
	name: String @search(by: [fulltext])
	eligibility: [HealthcareServiceEligibility]
	referralMethod: [CodeableConcept]
	communication: [CodeableConcept]
	location: [Location]
	photo: Attachment
	availabilityExceptions: String
	identifier: [Identifier]
	specialty: [CodeableConcept]
	availableTime: [HealthcareServiceAvailableTime]
	appointmentRequired: Boolean
	notAvailable: [HealthcareServiceNotAvailable]
	id: String! @id
	comment: String
	coverageArea: [Location]
	serviceProvisionCode: [CodeableConcept]
	endpoint: [Endpoint]
	providedBy: Organization
	telecom: [ContactPoint]
	category: [CodeableConcept]
	characteristic: [CodeableConcept]
	type: [CodeableConcept]
	extraDetails: String
	active: Boolean @search
}

type HealthcareServiceAvailableTime {
    daysOfWeek: [DaysOfWeek]
	allDay: Boolean
	id: String! @id
	availableStartTime: DateTime
	availableEndTime: DateTime
}

type HealthcareServiceEligibility {
    id: String! @id
	code: CodeableConcept
	comment: String
}

type HealthcareServiceNotAvailable {
    id: String! @id
	description: String!
	during: Period
}

type HumanName {
    given: [String] @search(by: [fulltext])
	prefix: [String]
	suffix: [String]
	text: String
	id: String! @id
	use: NameUse
	family: String @search(by: [fulltext])
	period: Period
}

type Identifier {
    system: String
	assigner: Reference
	id: String! @id
	use: IdentifierUse
	type: CodeableConcept
	value: String
	period: Period
}

type ImagingStudy {
    numberOfSeries: Int
	series: [ImagingStudySeries]
	procedureCode: [CodeableConcept]
	location: Location
	subject: ImagingStudySubject!
	identifier: [Identifier]
	description: String
	numberOfInstances: Int
	reasonCode: [CodeableConcept]
	id: String! @id
	procedureReference: Procedure
	note: [Annotation]
	status: ImagingStudyStatus!
	modality: [Coding]
	endpoint: [Endpoint]
	basedOn: [ImagingStudyBasedOn]
	referrer: ImagingStudyReferrer
	interpreter: [ImagingStudyInterpreter]
	started: DateTime @search
	reasonReference: [ImagingStudyReasonReference]
	encounter: Encounter
}

type ImagingStudyInstance {
    number: Int
	id: String! @id
	title: String
	sopClass: Coding!
	uniqueId: String!
}

type ImagingStudyPerformer {
    id: String! @id
	function: CodeableConcept
	actor: ImagingStudyPerformerActor!
}

type ImagingStudySeries {
    number: Int
	description: String
	instance: [ImagingStudyInstance]
	numberOfInstances: Int
	id: String! @id
	laterality: Coding
	modality: Coding!
	endpoint: [Endpoint]
	bodySite: Coding
	specimen: [Specimen]
	uniqueId: String!
	started: DateTime
	performer: [ImagingStudyPerformer]
}

type Immunization {
    expirationDate: DateTime
	statusReason: CodeableConcept
	protocolApplied: [ImmunizationProtocolApplied]
	location: Location
	identifier: [Identifier]
	subpotentReason: [CodeableConcept]
	site: CodeableConcept
	fundingSource: CodeableConcept
	reaction: [ImmunizationReaction]
	reasonCode: [CodeableConcept]
	doseQuantity: Quantity
	primarySource: Boolean
	id: String! @id
	education: [ImmunizationEducation]
	note: [Annotation]
	status: ImmunizationStatusCodes!
	recorded: DateTime
	programEligibility: [CodeableConcept]
	isSubpotent: Boolean
	lotNumber: String @search(by: [fulltext])
	route: CodeableConcept
	vaccineCode: CodeableConcept!
	manufacturer: Organization
	reasonReference: [ImmunizationReasonReference]
	reportOrigin: CodeableConcept
	encounter: Encounter
	performer: [ImmunizationPerformer]
	patient: Patient!
}

type ImmunizationEvaluation {
    series: String
	doseStatus: CodeableConcept!
	identifier: [Identifier]
	description: String
	targetDisease: CodeableConcept!
	id: String! @id
	date: DateTime @search
	status: ImmunizationEvaluationStatusCodes!
	immunizationEvent: Immunization!
	doseStatusReason: [CodeableConcept]
	authority: Organization
	patient: Patient!
}

type ImmunizationRecommendation {
    identifier: [Identifier]
	recommendation: [ImmunizationRecommendationRecommendation]
	id: String! @id
	date: DateTime! @search
	authority: Organization
	patient: Patient!
}

type ImmunizationRecommendationDateCriterion {
    id: String! @id
	code: CodeableConcept!
	value: DateTime!
}

type ImmunizationRecommendationRecommendation {
    series: String
	forecastReason: [CodeableConcept]
	description: String
	targetDisease: CodeableConcept
	doseNumberString: String
	supportingPatientInformation: [Resource]
	id: String! @id
	seriesDosesPositiveInt: Int
	seriesDosesString: String
	dateCriterion: [ImmunizationRecommendationDateCriterion]
	doseNumberPositiveInt: Int
	vaccineCode: [CodeableConcept]
	supportingImmunization: [ImmunizationRecommendationRecommendationSupportingImmunization]
	forecastStatus: CodeableConcept!
	contraindicatedVaccineCode: [CodeableConcept]
}

type ImmunizationPerformer {
    id: String! @id
	function: CodeableConcept
	actor: ImmunizationPerformerActor!
}

type ImmunizationProtocolApplied {
    series: String @search(by: [fulltext])
	targetDisease: [CodeableConcept]
	doseNumberString: String!
	id: String! @id
	seriesDosesPositiveInt: Int
	seriesDosesString: String
	doseNumberPositiveInt: Int!
	authority: Organization
}

type ImmunizationReaction {
    id: String! @id
	date: DateTime @search
	detail: Observation
	reported: Boolean
}

type ImplementationGuide {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean @search
	name: String! @search(by: [fulltext])
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	fhirVersion: [FHIRVersion]
	contact: [ContactDetail]
	license: SPDXLicense
	version: String @search(by: [exact])
	global: [ImplementationGuideGlobal]
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	dependsOn: [ImplementationGuideDependsOn]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	definition: ImplementationGuideDefinition
	manifest: ImplementationGuideManifest
	title: String @search(by: [fulltext])
	packageId: String!
}

type ImplementationGuideDefinition {
    parameter: [ImplementationGuideParameter]
	grouping: [ImplementationGuideGrouping]
	page: ImplementationGuidePage
	id: String! @id
	resource: [ImplementationGuideResource]
	template: [ImplementationGuideTemplate]
}

type ImplementationGuideManifest {
    image: [String]
	page: [ImplementationGuidePage1]
	id: String! @id
	resource: [ImplementationGuideResource1]
	rendering: String
	other: [String]
}

type ImplementationGuidePage {
    generation: GuidePageGeneration!
	page: [ImplementationGuidePage]
	nameUrl: String!
	nameReference: Reference!
	id: String! @id
	title: String!
}

type ImplementationGuideParameter {
    id: String! @id
	code: GuideParameterCode!
	value: String!
}

type ImplementationGuideResource {
    reference: Resource!
	name: String
	groupingId: String
	exampleCanonical: String
	description: String
	fhirVersion: [FHIRVersion]
	exampleBoolean: Boolean
	id: String! @id
}

type ImplementationGuideResource1 {
    reference: Resource!
	exampleCanonical: String
	relativePath: String
	exampleBoolean: Boolean
	id: String! @id
}

type InsurancePlan {
    network: [Organization]
	name: String @search(by: [fulltext])
	identifier: [Identifier]
	ownedBy: Organization
	coverage: [InsurancePlanCoverage]
	contact: [InsurancePlanContact]
	administeredBy: Organization
	alias: [String]
	id: String! @id
	status: PublicationStatus
	coverageArea: [Location]
	endpoint: [Endpoint]
	type: [CodeableConcept]
	plan: [InsurancePlanPlan]
	period: Period
}

type InsurancePlanBenefit {
    id: String! @id
	type: CodeableConcept!
	requirement: String
	limit: [InsurancePlanLimit]
}

type InsurancePlanBenefit1 {
    id: String! @id
	type: CodeableConcept!
	cost: [InsurancePlanCost]
}

type InsurancePlanContact {
    name: HumanName
	purpose: CodeableConcept
	id: String! @id
	telecom: [ContactPoint]
	address: Address
}

type InsurancePlanCost {
    applicability: CodeableConcept
	id: String! @id
	qualifiers: [CodeableConcept]
	type: CodeableConcept!
	value: Quantity
}

type InsurancePlanCoverage {
    id: String! @id
	type: CodeableConcept!
	network: [Organization]
	benefit: [InsurancePlanBenefit]
}

type InsurancePlanGeneralCost {
    groupSize: Int
	id: String! @id
	cost: Money
	comment: String
	type: CodeableConcept
}

type InsurancePlanLimit {
    id: String! @id
	value: Quantity
	code: CodeableConcept
}

type InsurancePlanPlan {
    network: [Organization]
	identifier: [Identifier]
	specificCost: [InsurancePlanSpecificCost]
	id: String! @id
	coverageArea: [Location]
	type: CodeableConcept
	generalCost: [InsurancePlanGeneralCost]
}

type InsurancePlanSpecificCost {
    id: String! @id
	category: CodeableConcept!
	benefit: [InsurancePlanBenefit1]
}

type Invoice {
    recipient: InvoiceRecipient
	participant: [InvoiceParticipant]
	totalGross: Money
	subject: InvoiceSubject
	identifier: [Identifier]
	issuer: Organization
	paymentTerms: String
	id: String! @id
	totalNet: Money
	date: DateTime @search
	note: [Annotation]
	status: InvoiceStatus!
	totalPriceComponent: [InvoicePriceComponent]
	cancelledReason: String
	account: Account
	type: CodeableConcept
	lineItem: [InvoiceLineItem]
}

type InvoiceLineItem {
    chargeItemCodeableConcept: CodeableConcept!
	id: String! @id
	sequence: Int
	chargeItemReference: ChargeItem!
	priceComponent: [InvoicePriceComponent]
}

type InvoiceParticipant {
    id: String! @id
	role: CodeableConcept
	actor: InvoiceParticipantActor!
}

type InvoicePriceComponent {
    amount: Money
	factor: Float
	code: CodeableConcept
	id: String! @id
	type: InvoicePriceComponentType!
}

type Library {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	parameter: [ParameterDefinition]
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	effectivePeriod: Period
	endorser: [ContactDetail]
	contact: [ContactDetail]
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	content: [Attachment]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	type: CodeableConcept!
	dataRequirement: [DataRequirement]
}

type Linkage {
    id: String! @id
	active: Boolean
	author: LinkageAuthor
	item: [LinkageItem]
}

type LinkageItem {
    id: String! @id
	type: LinkageType!
	resource: Resource!
}

type List {
    source: ListSource
	subject: ListSubject
	identifier: [Identifier]
	entry: [ListEntry]
	code: CodeableConcept
	id: String! @id
	orderedBy: CodeableConcept
	date: DateTime @search
	note: [Annotation]
	status: ListStatus!
	mode: ListMode!
	title: String @search(by: [fulltext])
	emptyReason: CodeableConcept
	encounter: Encounter
}

type ListEntry {
    id: String! @id
	date: DateTime
	flag: CodeableConcept
	deleted: Boolean
	item: Resource!
}

type Location {
    name: String @search(by: [fulltext])
	physicalType: CodeableConcept
	availabilityExceptions: String
	identifier: [Identifier]
	description: String
	operationalStatus: Coding
	alias: [String] @search(by: [fulltext])
	id: String! @id
	status: LocationStatus
	partOf: Location
	endpoint: [Endpoint]
	telecom: [ContactPoint]
	address: Address
	mode: LocationMode
	position: LocationPosition
	type: [CodeableConcept]
	managingOrganization: Organization
	hoursOfOperation: [LocationHoursOfOperation]
}

type LocationHoursOfOperation {
    closingTime: DateTime
	daysOfWeek: [DaysOfWeek]
	allDay: Boolean
	id: String! @id
	openingTime: DateTime
}

type MarketingStatus {
    jurisdiction: CodeableConcept
	restoreDate: DateTime
	country: CodeableConcept!
	id: String! @id
	status: CodeableConcept!
	dateRange: Period!
}

type Measure {
    clinicalRecommendationStatement: String
	copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	improvementNotation: CodeableConcept
	supplementalData: [MeasureSupplementalData]
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	disclaimer: String
	effectivePeriod: Period
	scoring: CodeableConcept
	endorser: [ContactDetail]
	rateAggregation: String
	contact: [ContactDetail]
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	guidance: String
	rationale: String
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	library: [String]
	riskAdjustment: String
	definition: [String]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	type: [CodeableConcept]
	compositeScoring: CodeableConcept
	group: [MeasureGroup]
}

type MeasureReport {
    measure: String!
	improvementNotation: CodeableConcept
	subject: MeasureReportSubject
	identifier: [Identifier]
	reporter: MeasureReportReporter
	evaluatedResource: [Resource]
	id: String! @id
	date: DateTime @search
	status: MeasureReportStatus!
	type: MeasureReportType!
	group: [MeasureReportGroup]
	period: Period!
}

type MeasureReportComponent {
    id: String! @id
	code: CodeableConcept!
	value: CodeableConcept!
}

type MeasureReportGroup {
    measureScore: Quantity
	population: [MeasureReportPopulation]
	code: CodeableConcept
	id: String! @id
	stratifier: [MeasureReportStratifier]
}

type MeasureReportPopulation {
    id: String! @id
	code: CodeableConcept
	count: Int
	subjectResults: List
}

type MeasureReportPopulation1 {
    id: String! @id
	code: CodeableConcept
	count: Int
	subjectResults: List
}

type MeasureReportStratifier {
    id: String! @id
	code: [CodeableConcept]
	stratum: [MeasureReportStratum]
}

type MeasureReportStratum {
    measureScore: Quantity
	population: [MeasureReportPopulation1]
	id: String! @id
	component: [MeasureReportComponent]
	value: CodeableConcept
}

type MeasureComponent {
    id: String! @id
	code: CodeableConcept
	description: String
	criteria: Expression!
}

type MeasureGroup {
    description: String
	population: [MeasurePopulation]
	code: CodeableConcept
	id: String! @id
	stratifier: [MeasureStratifier]
}

type MeasurePopulation {
    id: String! @id
	code: CodeableConcept
	description: String
	criteria: Expression!
}

type MeasureStratifier {
    description: String
	criteria: Expression
	code: CodeableConcept
	id: String! @id
	component: [MeasureComponent]
}

type MeasureSupplementalData {
    description: String
	usage: [CodeableConcept]
	criteria: Expression!
	code: CodeableConcept
	id: String! @id
}

type Media {
    deviceName: String
	duration: Float
	subject: MediaSubject
	identifier: [Identifier]
	frames: Int
	height: Int
	reasonCode: [CodeableConcept]
	issued: DateTime
	id: String! @id
	note: [Annotation]
	operator: MediaOperator
	status: EventStatus!
	modality: CodeableConcept
	partOf: [Resource]
	content: Attachment!
	basedOn: [MediaBasedOn]
	bodySite: CodeableConcept
	type: CodeableConcept
	width: Int
	encounter: Encounter
	device: MediaDevice
	view: CodeableConcept
}

type Medication {
    identifier: [Identifier]
	ingredient: [MedicationIngredient]
	amount: Ratio
	code: CodeableConcept
	batch: MedicationBatch
	id: String! @id
	status: MedicationStatusCodes
	manufacturer: Organization
	form: CodeableConcept
}

type MedicationAdministration {
    statusReason: [CodeableConcept]
	request: MedicationRequest
	subject: MedicationAdministrationSubject!
	identifier: [Identifier]
	context: MedicationAdministrationContext
	reasonCode: [CodeableConcept]
	id: String! @id
	instantiates: [String]
	note: [Annotation]
	status: String! @search(by: [exact])
	partOf: [MedicationAdministrationPartOf]
	category: CodeableConcept
	supportingInformation: [Resource]
	dosage: MedicationAdministrationDosage
	reasonReference: [MedicationAdministrationReasonReference]
	eventHistory: [Provenance]
	device: [Device]
	performer: [MedicationAdministrationPerformer]
}

type MedicationAdministrationDosage {
    method: CodeableConcept
	dose: Quantity
	site: CodeableConcept
	text: String
	rateRatio: Ratio
	rateQuantity: Quantity
	id: String! @id
	route: CodeableConcept
}

type MedicationAdministrationPerformer {
    id: String! @id
	function: CodeableConcept
	actor: MedicationAdministrationPerformerActor!
}

type MedicationDispense {
    authorizingPrescription: [MedicationRequest]
	quantity: Quantity
	location: Location
	subject: MedicationDispenseSubject
	whenPrepared: DateTime @search
	detectedIssue: [DetectedIssue]
	identifier: [Identifier]
	context: MedicationDispenseContext
	dosageInstruction: [Dosage]
	receiver: [MedicationDispenseReceiver]
	daysSupply: Quantity
	id: String! @id
	note: [Annotation]
	status: String! @search(by: [exact])
	partOf: [Procedure]
	whenHandedOver: DateTime @search
	category: CodeableConcept
	supportingInformation: [Resource]
	type: CodeableConcept
	substitution: MedicationDispenseSubstitution
	destination: Location
	eventHistory: [Provenance]
	performer: [MedicationDispensePerformer]
}

type MedicationDispensePerformer {
    id: String! @id
	function: CodeableConcept
	actor: MedicationDispensePerformerActor!
}

type MedicationDispenseSubstitution {
    reason: [CodeableConcept]
	wasSubstituted: Boolean!
	id: String! @id
	type: CodeableConcept
	responsibleParty: [MedicationDispenseSubstitutionResponsibleParty]
}

type MedicationKnowledge {
    packaging: MedicationKnowledgePackaging
	associatedMedication: [Medication]
	monitoringProgram: [MedicationKnowledgeMonitoringProgram]
	preparationInstruction: String
	contraindication: [DetectedIssue]
	drugCharacteristic: [MedicationKnowledgeDrugCharacteristic]
	relatedMedicationKnowledge: [MedicationKnowledgeRelatedMedicationKnowledge]
	ingredient: [MedicationKnowledgeIngredient]
	productType: [CodeableConcept]
	synonym: [String]
	amount: Quantity
	code: CodeableConcept
	id: String! @id
	monograph: [MedicationKnowledgeMonograph]
	medicineClassification: [MedicationKnowledgeMedicineClassification]
	cost: [MedicationKnowledgeCost]
	status: String @search(by: [exact])
	regulatory: [MedicationKnowledgeRegulatory]
	doseForm: CodeableConcept
	administrationGuidelines: [MedicationKnowledgeAdministrationGuidelines]
	kinetics: [MedicationKnowledgeKinetics]
	manufacturer: Organization
	intendedRoute: [CodeableConcept]
}

type MedicationKnowledgeAdministrationGuidelines {
    patientCharacteristics: [MedicationKnowledgePatientCharacteristics]
	indicationReference: Reference
	id: String! @id
	dosage: [MedicationKnowledgeDosage]
	indicationCodeableConcept: CodeableConcept
}

type MedicationKnowledgeCost {
    id: String! @id
	type: CodeableConcept!
	source: String @search(by: [exact])
	cost: Money!
}

type MedicationKnowledgeDosage {
    id: String! @id
	type: CodeableConcept!
	dosage: [Dosage]
}

type MedicationKnowledgeDrugCharacteristic {
    valueQuantity: Quantity
	valueString: String
	id: String! @id
	valueBase64Binary: String
	type: CodeableConcept
	valueCodeableConcept: CodeableConcept
}

type MedicationKnowledgeIngredient {
    itemReference: Reference!
	strength: Ratio
	id: String! @id
	itemCodeableConcept: CodeableConcept!
	isActive: Boolean
}

type MedicationKnowledgeKinetics {
    id: String! @id
	areaUnderCurve: [Quantity]
	lethalDose50: [Quantity]
	halfLifePeriod: Duration
}

type MedicationKnowledgeMaxDispense {
    id: String! @id
	quantity: Quantity!
	period: Duration
}

type MedicationKnowledgeMedicineClassification {
    id: String! @id
	type: CodeableConcept!
	classification: [CodeableConcept]
}

type MedicationKnowledgeMonitoringProgram {
    id: String! @id
	type: CodeableConcept
	name: String @search(by: [exact])
}

type MedicationKnowledgeMonograph {
    id: String! @id
	type: CodeableConcept
	source: MedicationKnowledgeMonographSource
}

type MedicationKnowledgePackaging {
    id: String! @id
	type: CodeableConcept
	quantity: Quantity
}

type MedicationKnowledgePatientCharacteristics {
    id: String! @id
	value: [String]
	characteristicCodeableConcept: CodeableConcept!
	characteristicQuantity: Quantity!
}

type MedicationKnowledgeRegulatory {
    id: String! @id
	maxDispense: MedicationKnowledgeMaxDispense
	schedule: [MedicationKnowledgeSchedule]
	substitution: [MedicationKnowledgeSubstitution]
	regulatoryAuthority: Organization!
}

type MedicationKnowledgeRelatedMedicationKnowledge {
    id: String! @id
	type: CodeableConcept!
	reference: [MedicationKnowledge]
}

type MedicationKnowledgeSchedule {
    id: String! @id
	schedule: CodeableConcept!
}

type MedicationKnowledgeSubstitution {
    id: String! @id
	type: CodeableConcept!
	allowed: Boolean!
}

type MedicationRequest {
    priority: RequestPriority
	statusReason: CodeableConcept
	subject: MedicationRequestSubject!
	performerType: CodeableConcept
	instantiatesUri: [String]
	insurance: [MedicationRequestInsurance]
	detectedIssue: [DetectedIssue]
	identifier: [Identifier]
	intent: MedicationRequestIntent!
	authoredOn: DateTime @search
	dosageInstruction: [Dosage]
	requester: MedicationRequestRequester
	reasonCode: [CodeableConcept]
	doNotPerform: Boolean
	id: String! @id
	note: [Annotation]
	status: MedicationrequestStatus!
	groupIdentifier: Identifier
	category: [CodeableConcept]
	basedOn: [MedicationRequestBasedOn]
	supportingInformation: [Resource]
	courseOfTherapyType: CodeableConcept
	priorPrescription: MedicationRequest
	substitution: MedicationRequestSubstitution
	reasonReference: [MedicationRequestReasonReference]
	eventHistory: [Provenance]
	instantiatesCanonical: [String]
	encounter: Encounter
	performer: MedicationRequestPerformer
	recorder: MedicationRequestRecorder
	dispenseRequest: MedicationRequestDispenseRequest
}

type MedicationRequestDispenseRequest {
    dispenseInterval: Duration
	validityPeriod: Period
	quantity: Quantity
	numberOfRepeatsAllowed: Int
	id: String! @id
	expectedSupplyDuration: Duration
	performer: Organization
	initialFill: MedicationRequestInitialFill
}

type MedicationRequestInitialFill {
    id: String! @id
	quantity: Quantity
	duration: Duration
}

type MedicationRequestSubstitution {
    id: String! @id
	reason: CodeableConcept
	allowedBoolean: Boolean!
	allowedCodeableConcept: CodeableConcept!
}

type MedicationStatement {
    statusReason: [CodeableConcept]
	subject: MedicationStatementSubject!
	identifier: [Identifier]
	context: MedicationStatementContext
	derivedFrom: [Resource]
	reasonCode: [CodeableConcept]
	id: String! @id
	dateAsserted: DateTime
	informationSource: MedicationStatementInformationSource
	note: [Annotation]
	status: MedicationStatusCodes!
	partOf: [MedicationStatementPartOf]
	category: CodeableConcept
	basedOn: [MedicationStatementBasedOn]
	dosage: [Dosage]
	reasonReference: [MedicationStatementReasonReference]
}

type MedicationIngredient {
    itemReference: Reference!
	strength: Ratio
	id: String! @id
	itemCodeableConcept: CodeableConcept!
	isActive: Boolean
}

type MedicinalProduct {
    clinicalTrial: [ResearchStudy]
	name: [MedicinalProductName]
	packagedMedicinalProduct: [MedicinalProductPackaged]
	crossReference: [Identifier]
	identifier: [Identifier]
	specialMeasures: [String]
	domain: Coding
	paediatricUseIndicator: CodeableConcept
	combinedPharmaceuticalDoseForm: CodeableConcept
	legalStatusOfSupply: CodeableConcept
	contact: [MedicinalProductContact]
	pharmaceuticalProduct: [MedicinalProductPharmaceutical]
	productClassification: [CodeableConcept]
	id: String! @id
	specialDesignation: [MedicinalProductSpecialDesignation]
	manufacturingBusinessOperation: [MedicinalProductManufacturingBusinessOperation]
	masterFile: [DocumentReference]
	additionalMonitoringIndicator: CodeableConcept
	marketingStatus: [MarketingStatus]
	type: CodeableConcept
	attachedDocument: [DocumentReference]
}

type MedicinalProductAuthorization {
    jurisdiction: [CodeableConcept]
	jurisdictionalAuthorization: [MedicinalProductAuthorizationJurisdictionalAuthorization]
	validityPeriod: Period
	subject: MedicinalProductAuthorizationSubject
	restoreDate: DateTime
	identifier: [Identifier]
	dataExclusivityPeriod: Period
	statusDate: DateTime
	procedure: MedicinalProductAuthorizationProcedure
	country: [CodeableConcept]
	holder: Organization
	internationalBirthDate: DateTime
	id: String! @id
	status: CodeableConcept
	dateOfFirstAuthorization: DateTime
	legalBasis: CodeableConcept
	regulator: Organization
}

type MedicinalProductAuthorizationJurisdictionalAuthorization {
    jurisdiction: [CodeableConcept]
	validityPeriod: Period
	identifier: [Identifier]
	legalStatusOfSupply: CodeableConcept
	country: CodeableConcept
	id: String! @id
}

type MedicinalProductAuthorizationProcedure {
    application: [MedicinalProductAuthorizationProcedure]
	datePeriod: Period
	identifier: Identifier
	id: String! @id
	type: CodeableConcept!
	dateDateTime: DateTime
}

type MedicinalProductContraindication {
    subject: [MedicinalProductContraindicationSubject]
	population: [Population]
	diseaseStatus: CodeableConcept
	id: String! @id
	disease: CodeableConcept
	comorbidity: [CodeableConcept]
	otherTherapy: [MedicinalProductContraindicationOtherTherapy]
	therapeuticIndication: [MedicinalProductIndication]
}

type MedicinalProductContraindicationOtherTherapy {
    id: String! @id
	therapyRelationshipType: CodeableConcept!
	medicationCodeableConcept: CodeableConcept!
	medicationReference: Reference!
}

type MedicinalProductIndication {
    duration: Quantity
	subject: [MedicinalProductIndicationSubject]
	diseaseSymptomProcedure: CodeableConcept
	population: [Population]
	undesirableEffect: [MedicinalProductUndesirableEffect]
	diseaseStatus: CodeableConcept
	id: String! @id
	intendedEffect: CodeableConcept
	comorbidity: [CodeableConcept]
	otherTherapy: [MedicinalProductIndicationOtherTherapy]
}

type MedicinalProductIndicationOtherTherapy {
    id: String! @id
	therapyRelationshipType: CodeableConcept!
	medicationCodeableConcept: CodeableConcept!
	medicationReference: Reference!
}

type MedicinalProductIngredient {
    substance: MedicinalProductIngredientSubstance
	specifiedSubstance: [MedicinalProductIngredientSpecifiedSubstance]
	identifier: Identifier
	role: CodeableConcept!
	allergenicIndicator: Boolean
	id: String! @id
	manufacturer: [Organization]
}

type MedicinalProductIngredientReferenceStrength {
    strengthLowLimit: Ratio
	substance: CodeableConcept
	strength: Ratio!
	country: [CodeableConcept]
	measurementPoint: String
	id: String! @id
}

type MedicinalProductIngredientSpecifiedSubstance {
    strength: [MedicinalProductIngredientStrength]
	code: CodeableConcept!
	confidentiality: CodeableConcept
	id: String! @id
	group: CodeableConcept!
}

type MedicinalProductIngredientStrength {
    concentrationLowLimit: Ratio
	concentration: Ratio
	presentationLowLimit: Ratio
	country: [CodeableConcept]
	measurementPoint: String
	referenceStrength: [MedicinalProductIngredientReferenceStrength]
	id: String! @id
	presentation: Ratio!
}

type MedicinalProductIngredientSubstance {
    id: String! @id
	code: CodeableConcept!
	strength: [MedicinalProductIngredientStrength]
}

type MedicinalProductInteraction {
    interactant: [MedicinalProductInteractionInteractant]
	subject: [MedicinalProductInteractionSubject]
	description: String
	effect: CodeableConcept
	incidence: CodeableConcept
	id: String! @id
	management: CodeableConcept
	type: CodeableConcept
}

type MedicinalProductInteractionInteractant {
    id: String! @id
	itemReference: MedicinalProductInteractionInteractantItemReference!
	itemCodeableConcept: CodeableConcept!
}

type MedicinalProductManufactured {
    quantity: Quantity!
	unitOfPresentation: CodeableConcept
	manufacturedDoseForm: CodeableConcept!
	ingredient: [MedicinalProductIngredient]
	id: String! @id
	physicalCharacteristics: ProdCharacteristic
	manufacturer: [Organization]
	otherCharacteristics: [CodeableConcept]
}

type MedicinalProductPackaged {
    subject: [MedicinalProduct]
	batchIdentifier: [MedicinalProductPackagedBatchIdentifier]
	identifier: [Identifier]
	description: String
	legalStatusOfSupply: CodeableConcept
	packageItem: [MedicinalProductPackagedPackageItem]
	id: String! @id
	marketingStatus: [MarketingStatus]
	manufacturer: [Organization]
	marketingAuthorization: MedicinalProductAuthorization
}

type MedicinalProductPackagedBatchIdentifier {
    id: String! @id
	outerPackaging: Identifier!
	immediatePackaging: Identifier
}

type MedicinalProductPackagedPackageItem {
    quantity: Quantity!
	identifier: [Identifier]
	alternateMaterial: [CodeableConcept]
	packageItem: [MedicinalProductPackagedPackageItem]
	id: String! @id
	physicalCharacteristics: ProdCharacteristic
	material: [CodeableConcept]
	manufacturer: [Organization]
	type: CodeableConcept!
	manufacturedItem: [MedicinalProductManufactured]
	device: [DeviceDefinition]
	shelfLifeStorage: [ProductShelfLife]
	otherCharacteristics: [CodeableConcept]
}

type MedicinalProductPharmaceutical {
    unitOfPresentation: CodeableConcept
	identifier: [Identifier]
	routeOfAdministration: [MedicinalProductPharmaceuticalRouteOfAdministration]
	ingredient: [MedicinalProductIngredient]
	administrableDoseForm: CodeableConcept!
	id: String! @id
	characteristics: [MedicinalProductPharmaceuticalCharacteristics]
	device: [DeviceDefinition]
}

type MedicinalProductPharmaceuticalCharacteristics {
    id: String! @id
	code: CodeableConcept!
	status: CodeableConcept
}

type MedicinalProductPharmaceuticalRouteOfAdministration {
    maxDosePerTreatmentPeriod: Ratio
	targetSpecies: [MedicinalProductPharmaceuticalTargetSpecies]
	firstDose: Quantity
	maxDosePerDay: Quantity
	code: CodeableConcept!
	id: String! @id
	maxTreatmentPeriod: Duration
	maxSingleDose: Quantity
}

type MedicinalProductPharmaceuticalTargetSpecies {
    id: String! @id
	code: CodeableConcept!
	withdrawalPeriod: [MedicinalProductPharmaceuticalWithdrawalPeriod]
}

type MedicinalProductPharmaceuticalWithdrawalPeriod {
    id: String! @id
	tissue: CodeableConcept!
	value: Quantity!
	supportingInformation: String
}

type MedicinalProductUndesirableEffect {
    symptomConditionEffect: CodeableConcept
	subject: [MedicinalProductUndesirableEffectSubject]
	population: [Population]
	id: String! @id
	classification: CodeableConcept
	frequencyOfOccurrence: CodeableConcept
}

type MedicinalProductCountryLanguage {
    id: String! @id
	country: CodeableConcept!
	jurisdiction: CodeableConcept
	language: CodeableConcept!
}

type MedicinalProductManufacturingBusinessOperation {
    operationType: CodeableConcept
	confidentialityIndicator: CodeableConcept
	id: String! @id
	effectiveDate: DateTime
	manufacturer: [Organization]
	authorisationReferenceNumber: Identifier
	regulator: Organization
}

type MedicinalProductName {
    id: String! @id
	productName: String! @search(by: [fulltext])
	namePart: [MedicinalProductNamePart]
	countryLanguage: [MedicinalProductCountryLanguage]
}

type MedicinalProductNamePart {
    id: String! @id
	part: String!
	type: Coding!
}

type MedicinalProductSpecialDesignation {
    species: CodeableConcept
	intendedUse: CodeableConcept
	identifier: [Identifier]
	indicationReference: Reference
	id: String! @id
	date: DateTime
	status: CodeableConcept
	type: CodeableConcept
	indicationCodeableConcept: CodeableConcept
}

type MessageDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	parent: [String]
	name: String @search(by: [fulltext])
	responseRequired: MessageheaderResponseRequest
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	allowedResponse: [MessageDefinitionAllowedResponse]
	contact: [ContactDetail]
	purpose: String
	base: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	focus: [MessageDefinitionFocus]
	date: DateTime! @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	category: MessageSignificanceCategory
	graph: [String]
	title: String @search(by: [fulltext])
	replaces: [String]
}

type MessageHeader {
    author: MessageHeaderAuthor
	source: MessageHeaderSource!
	responsible: MessageHeaderResponsible
	reason: CodeableConcept
	response: MessageHeaderResponse
	id: String! @id
	focus: [Resource]
	definition: String
	sender: MessageHeaderSender
	destination: [MessageHeaderDestination]
	enterer: MessageHeaderEnterer
}

type MessageHeaderDestination {
    name: String @search(by: [fulltext])
	receiver: MessageHeaderDestinationReceiver
	id: String! @id
	endpoint: String! @search(by: [exact])
	target: Device
}

type MessageHeaderResponse {
    id: String! @id
	identifier: String! @search(by: [exact])
	code: ResponseType!
	details: OperationOutcome
}

type MessageHeaderSource {
    name: String @search(by: [fulltext])
	contact: ContactPoint
	version: String
	id: String! @id
	software: String
	endpoint: String! @search(by: [exact])
}

type Meta {
    source: String @search(by: [exact])
	versionId: String
	security: [Coding]
	lastUpdated: DateTime @search
	tag: [Coding]
	id: String! @id
	profile: [String] @search(by: [exact])
}

type MolecularSequence {
    quality: [MolecularSequenceQuality]
	quantity: Quantity
	repository: [MolecularSequenceRepository]
	pointer: [MolecularSequence]
	observedSeq: String
	identifier: [Identifier]
	referenceSeq: MolecularSequenceReferenceSeq
	variant: [MolecularSequenceVariant]
	coordinateSystem: Int!
	id: String! @id
	type: SequenceType
	specimen: Specimen
	structureVariant: [MolecularSequenceStructureVariant]
	device: Device
	performer: Organization
	readCoverage: Int
	patient: Patient
}

type MolecularSequenceQuality {
    method: CodeableConcept
	truthFN: Float
	truthTP: Float
	precision: Float
	score: Quantity
	queryTP: Float
	standardSequence: CodeableConcept
	id: String! @id
	fScore: Float
	queryFP: Float
	end: Int
	recall: Float
	roc: MolecularSequenceRoc
	type: QualityType!
	start: Int
	gtFP: Float
}

type MolecularSequenceReferenceSeq {
    referenceSeqString: String
	genomeBuild: String
	chromosome: CodeableConcept
	id: String! @id
	windowEnd: Int
	orientation: OrientationType
	referenceSeqId: CodeableConcept
	strand: StrandType
	referenceSeqPointer: MolecularSequence
	windowStart: Int
}

type MolecularSequenceRepository {
    name: String
	readsetId: String
	url: String
	datasetId: String
	id: String! @id
	variantsetId: String
	type: RepositoryType!
}

type MolecularSequenceStructureVariant {
    outer: MolecularSequenceOuter
	exact: Boolean
	id: String! @id
	length: Int
	variantType: CodeableConcept
	inner: MolecularSequenceInner
}

type MolecularSequenceVariant {
    referenceAllele: String
	id: String! @id
	end: Int
	cigar: String
	start: Int
	observedAllele: String
	variantPointer: Observation
}

type NamingSystem {
    jurisdiction: [CodeableConcept]
	name: String! @search(by: [fulltext])
	description: String @search(by: [fulltext])
	usage: String
	responsible: String @search(by: [fulltext])
	contact: [ContactDetail]
	useContext: [UsageContext]
	id: String! @id
	date: DateTime! @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	kind: NamingSystemType!
	type: CodeableConcept
	uniqueId: [NamingSystemUniqueId]
}

type NamingSystemUniqueId {
    preferred: Boolean
	id: String! @id
	comment: String
	type: NamingSystemIdentifierType!
	value: String! @search(by: [fulltext])
	period: Period
}

type Narrative {
    id: String! @id
	status: NarrativeStatus!
}

type NutritionOrder_ {
    supplement: [NutritionOrderSupplement]
	excludeFoodModifier: [CodeableConcept]
	allergyIntolerance: [AllergyIntolerance]
	instantiatesUri: [String]
	identifier: [Identifier]
	intent: RequestIntent!
	enteralFormula: NutritionOrderEnteralFormula
	oralDiet: NutritionOrderOralDiet
	orderer: NutritionOrderOrderer
	dateTime: DateTime!
	id: String! @id
	instantiates: [String]
	note: [Annotation]
	status: RequestStatus!
	foodPreferenceModifier: [CodeableConcept]
	instantiatesCanonical: [String]
	encounter: Encounter
	patient: Patient!
}

type NutritionOrderAdministration {
    quantity: Quantity
	rateRatio: Ratio
	rateQuantity: Quantity
	id: String! @id
	schedule: Timing
}

type NutritionOrderEnteralFormula {
    baseFormulaType: CodeableConcept
	maxVolumeToDeliver: Quantity
	id: String! @id
	administration: [NutritionOrderAdministration]
	caloricDensity: Quantity
	routeofAdministration: CodeableConcept
	additiveType: CodeableConcept
	administrationInstruction: String
	baseFormulaProductName: String
	additiveProductName: String
}

type NutritionOrderNutrient {
    id: String! @id
	modifier: CodeableConcept
	amount: Quantity
}

type NutritionOrderOralDiet {
    instruction: String
	nutrient: [NutritionOrderNutrient]
	id: String! @id
	schedule: [Timing]
	type: [CodeableConcept]
	fluidConsistencyType: [CodeableConcept]
	texture: [NutritionOrderTexture]
}

type NutritionOrderSupplement {
    quantity: Quantity
	instruction: String
	id: String! @id
	schedule: [Timing]
	productName: String
	type: CodeableConcept
}

type NutritionOrderTexture {
    id: String! @id
	modifier: CodeableConcept
	foodType: CodeableConcept
}

type Observation {
    method: CodeableConcept
	subject: ObservationSubject
	identifier: [Identifier]
	referenceRange: [ObservationReferenceRange]
	derivedFrom: [ObservationDerivedFrom]
	interpretation: [CodeableConcept]
	hasMember: [ObservationHasMember]
	code: CodeableConcept!
	issued: DateTime
	id: String! @id
	focus: [Resource]
	note: [Annotation]
	status: ObservationStatus!
	partOf: [ObservationPartOf]
	category: [CodeableConcept]
	basedOn: [ObservationBasedOn]
	dataAbsentReason: CodeableConcept
	bodySite: CodeableConcept
	specimen: Specimen
	component: [ObservationComponent]
	encounter: Encounter
	device: ObservationDevice
	performer: [ObservationPerformer]
}

type ObservationDefinition {
    method: CodeableConcept
	identifier: [Identifier]
	multipleResultsAllowed: Boolean
	qualifiedInterval: [ObservationDefinitionQualifiedInterval]
	criticalCodedValueSet: ValueSet
	validCodedValueSet: ValueSet
	code: CodeableConcept!
	abnormalCodedValueSet: ValueSet
	normalCodedValueSet: ValueSet
	preferredReportName: String
	id: String! @id
	quantitativeDetails: ObservationDefinitionQuantitativeDetails
	category: [CodeableConcept]
	permittedDataType: [ObservationDataType]
}

type ObservationDefinitionQualifiedInterval {
    gestationalAge: Range
	context: CodeableConcept
	age: Range
	id: String! @id
	condition: String
	range: Range
	category: ObservationRangeCategory
	appliesTo: [CodeableConcept]
	gender: AdministrativeGender
}

type ObservationDefinitionQuantitativeDetails {
    customaryUnit: CodeableConcept
	id: String! @id
	conversionFactor: Float
	decimalPrecision: Int
	unit: CodeableConcept
}

type ObservationComponent {
    valueQuantity: Quantity
	referenceRange: [ObservationReferenceRange]
	valueString: String
	valueBoolean: Boolean
	interpretation: [CodeableConcept]
	code: CodeableConcept!
	valueRange: Range
	valueDateTime: DateTime
	valueInteger: Int
	id: String! @id
	valuePeriod: Period
	valueTime: DateTime
	valueSampledData: SampledData
	dataAbsentReason: CodeableConcept
	valueRatio: Ratio
	valueCodeableConcept: CodeableConcept
}

type ObservationReferenceRange {
    text: String
	age: Range
	low: Quantity
	id: String! @id
	type: CodeableConcept
	appliesTo: [CodeableConcept]
	high: Quantity
}

type OperationDefinition {
    jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String! @search(by: [fulltext])
	parameter: [OperationDefinitionParameter]
	system: Boolean! @search
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	overload: [OperationDefinitionOverload]
	instance: Boolean! @search
	contact: [ContactDetail]
	purpose: String
	base: String
	code: String! @search(by: [exact])
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	resource: [String]
	affectsState: Boolean
	inputProfile: String
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	comment: String
	outputProfile: String
	kind: OperationKind!
	title: String @search(by: [fulltext])
	type: Boolean! @search
}

type OperationDefinitionBinding {
    id: String! @id
	strength: BindingStrength!
	valueSet: String!
}

type OperationDefinitionParameter {
    name: String!
	binding: OperationDefinitionBinding
	targetProfile: [String]
	documentation: String
	searchType: SearchParamType
	min: Int!
	referencedFrom: [OperationDefinitionReferencedFrom]
	id: String! @id
	max: String!
	use: OperationParameterUse!
	part: [OperationDefinitionParameter]
	type: String
}

type OperationOutcome {
    id: String! @id
	issue: [OperationOutcomeIssue]
}

type OperationOutcomeIssue {
    location: [String]
	code: IssueType!
	id: String! @id
	expression: [String]
	diagnostics: String
	details: CodeableConcept
	severity: IssueSeverity!
}

type Organization {
    name: String @search(by: [fulltext])
	identifier: [Identifier]
	contact: [OrganizationContact]
	alias: [String] @search(by: [fulltext])
	id: String! @id
	partOf: Organization
	endpoint: [Endpoint]
	telecom: [ContactPoint]
	address: [Address]
	type: [CodeableConcept]
	active: Boolean @search
}

type OrganizationAffiliation {
    organization: Organization
	network: [Organization]
	participatingOrganization: Organization
	location: [Location]
	identifier: [Identifier]
	specialty: [CodeableConcept]
	healthcareService: [HealthcareService]
	code: [CodeableConcept]
	id: String! @id
	endpoint: [Endpoint]
	telecom: [ContactPoint]
	period: Period
	active: Boolean @search
}

type OrganizationContact {
    name: HumanName
	purpose: CodeableConcept
	id: String! @id
	telecom: [ContactPoint]
	address: Address
}

type Parameters {
    id: String! @id
	parameter: [ParametersParameter]
}

type ParametersParameter {
    valueDecimal: Float
	valueHumanName: HumanName
	name: String!
	valueCode: String
	valueDosage: Dosage
	valueMarkdown: String
	valueUri: String
	valueContactDetail: ContactDetail
	valueAge: Age
	valueUsageContext: UsageContext
	valueQuantity: Quantity
	valueDataRequirement: DataRequirement
	valueCount: Count
	valueString: String
	valueBoolean: Boolean
	valueIdentifier: Identifier
	valueDistance: Distance
	valueMoney: Money
	valueDate: DateTime
	valueRange: Range
	valueDateTime: DateTime
	valueId: String
	valueUnsignedInt: Int
	valueMeta: Meta
	valueInteger: Int
	id: String! @id
	valuePositiveInt: Int
	resource: ResourceContainer
	valueParameterDefinition: ParameterDefinition
	valuePeriod: Period
	valueReference: Reference
	valueContactPoint: ContactPoint
	valueTime: DateTime
	valueTriggerDefinition: TriggerDefinition
	valueUuid: String
	valueRelatedArtifact: RelatedArtifact
	valueInstant: DateTime
	valueExpression: Expression
	valueBase64Binary: String
	valueOid: String
	valueSampledData: SampledData
	valueContributor: Contributor
	part: [ParametersParameter]
	valueCoding: Coding
	valueUrl: String
	valueRatio: Ratio
	valueDuration: Duration
	valueCanonical: String
	valueCodeableConcept: CodeableConcept
	valueAnnotation: Annotation
	valueAttachment: Attachment
	valueAddress: Address
	valueTiming: Timing
	valueSignature: Signature
}

type Patient {
    name: [HumanName]
	communication: [PatientCommunication]
	photo: [Attachment]
	identifier: [Identifier]
	generalPractitioner: [PatientGeneralPractitioner]
	contact: [PatientContact]
	birthDate: DateTime @search
	id: String! @id
	link: [PatientLink]
	maritalStatus: CodeableConcept
	telecom: [ContactPoint]
	address: [Address]
	managingOrganization: Organization
	gender: AdministrativeGender
	active: Boolean @search
}

type PatientCommunication {
    id: String! @id
	language: CodeableConcept!
	preferred: Boolean
}

type PatientContact {
    organization: Organization
	name: HumanName
	relationship: [CodeableConcept]
	id: String! @id
	telecom: [ContactPoint]
	address: Address
	period: Period
	gender: AdministrativeGender
}

type PatientLink {
    id: String! @id
	other: PatientLinkOther!
	type: LinkType!
}

type PaymentNotice {
    recipient: Organization!
	request: Resource
	provider: PaymentNoticeProvider
	identifier: [Identifier]
	paymentStatus: CodeableConcept
	amount: Money!
	payment: PaymentReconciliation!
	response: Resource
	id: String! @id
	status: FinancialResourceStatusCodes!
	paymentDate: DateTime
	payee: PaymentNoticePayee
	created: DateTime! @search
}

type PaymentReconciliation {
    requestor: PaymentReconciliationRequestor
	request: Task
	identifier: [Identifier]
	disposition: String @search(by: [fulltext])
	paymentAmount: Money!
	outcome: RemittanceOutcome
	id: String! @id
	processNote: [PaymentReconciliationProcessNote]
	formCode: CodeableConcept
	status: FinancialResourceStatusCodes!
	paymentIdentifier: Identifier
	paymentDate: DateTime!
	detail: [PaymentReconciliationDetail]
	paymentIssuer: Organization
	period: Period
	created: DateTime! @search
}

type PaymentReconciliationDetail {
    request: Resource
	identifier: Identifier
	responsible: PractitionerRole
	amount: Money
	response: Resource
	id: String! @id
	date: DateTime
	submitter: PaymentReconciliationDetailSubmitter
	type: CodeableConcept!
	payee: PaymentReconciliationDetailPayee
	predecessor: Identifier
}

type PaymentReconciliationProcessNote {
    id: String! @id
	type: NoteType
	text: String
}

type Person {
    name: [HumanName]
	photo: Attachment
	identifier: [Identifier]
	birthDate: DateTime @search
	id: String! @id
	link: [PersonLink]
	telecom: [ContactPoint]
	address: [Address]
	managingOrganization: Organization
	gender: AdministrativeGender
	active: Boolean
}

type PersonLink {
    id: String! @id
	target: PersonLinkTarget!
	assurance: IdentityAssuranceLevel
}

type PlanDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	effectivePeriod: Period
	endorser: [ContactDetail]
	goal: [PlanDefinitionGoal]
	contact: [ContactDetail]
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	library: [String]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	type: CodeableConcept
	action: [PlanDefinitionAction]
}

type PlanDefinitionAction {
    participant: [PlanDefinitionParticipant]
	priority: RequestPriority
	timingDuration: Duration
	timingPeriod: Period
	subjectReference: Reference
	cardinalityBehavior: ActionCardinalityBehavior
	groupingBehavior: ActionGroupingBehavior
	description: String
	prefix: String
	documentation: [RelatedArtifact]
	relatedAction: [PlanDefinitionRelatedAction]
	goalId: [String]
	subjectCodeableConcept: CodeableConcept
	reason: [CodeableConcept]
	timingRange: Range
	code: [CodeableConcept]
	timingAge: Age
	id: String! @id
	condition: [PlanDefinitionCondition]
	timingTiming: Timing
	timingDateTime: DateTime
	definitionCanonical: String
	dynamicValue: [PlanDefinitionDynamicValue]
	definitionUri: String
	title: String
	output: [DataRequirement]
	type: CodeableConcept
	precheckBehavior: ActionPrecheckBehavior
	transform: String
	action: [PlanDefinitionAction]
	input: [DataRequirement]
	selectionBehavior: ActionSelectionBehavior
	requiredBehavior: ActionRequiredBehavior
	textEquivalent: String
	trigger: [TriggerDefinition]
}

type PlanDefinitionCondition {
    id: String! @id
	kind: ActionConditionKind!
	expression: Expression
}

type PlanDefinitionDynamicValue {
    id: String! @id
	path: String
	expression: Expression
}

type PlanDefinitionGoal {
    priority: CodeableConcept
	description: CodeableConcept!
	documentation: [RelatedArtifact]
	id: String! @id
	category: CodeableConcept
	target: [PlanDefinitionTarget]
	start: CodeableConcept
	addresses: [CodeableConcept]
}

type PlanDefinitionParticipant {
    id: String! @id
	type: ActionParticipantType!
	role: CodeableConcept
}

type PlanDefinitionRelatedAction {
    offsetDuration: Duration
	actionId: String!
	offsetRange: Range
	relationship: ActionRelationshipType!
	id: String! @id
}

type PlanDefinitionTarget {
    measure: CodeableConcept
	detailRange: Range
	due: Duration
	detailQuantity: Quantity
	detailCodeableConcept: CodeableConcept
	id: String! @id
}

type Population {
    ageRange: Range
	id: String! @id
	ageCodeableConcept: CodeableConcept
	race: CodeableConcept
	physiologicalCondition: CodeableConcept
	gender: CodeableConcept
}

type Practitioner {
    name: [HumanName]
	communication: [CodeableConcept]
	qualification: [PractitionerQualification]
	photo: [Attachment]
	identifier: [Identifier]
	birthDate: DateTime
	id: String! @id
	telecom: [ContactPoint]
	address: [Address]
	gender: AdministrativeGender
	active: Boolean @search
}

type PractitionerRole {
    practitioner: Practitioner
	organization: Organization
	location: [Location]
	availabilityExceptions: String
	identifier: [Identifier]
	specialty: [CodeableConcept]
	availableTime: [PractitionerRoleAvailableTime]
	healthcareService: [HealthcareService]
	notAvailable: [PractitionerRoleNotAvailable]
	code: [CodeableConcept]
	id: String! @id
	endpoint: [Endpoint]
	telecom: [ContactPoint]
	period: Period
	active: Boolean @search
}

type PractitionerRoleAvailableTime {
    daysOfWeek: [DaysOfWeek]
	allDay: Boolean
	id: String! @id
	availableStartTime: DateTime
	availableEndTime: DateTime
}

type PractitionerRoleNotAvailable {
    id: String! @id
	description: String!
	during: Period
}

type PractitionerQualification {
    identifier: [Identifier]
	issuer: Organization
	code: CodeableConcept!
	id: String! @id
	period: Period
}

type Procedure {
    followUp: [CodeableConcept]
	statusReason: CodeableConcept
	location: Location
	subject: ProcedureSubject!
	instantiatesUri: [String] @search(by: [exact])
	identifier: [Identifier]
	outcome: CodeableConcept
	reasonCode: [CodeableConcept]
	usedCode: [CodeableConcept]
	code: CodeableConcept
	id: String! @id
	note: [Annotation]
	status: EventStatus!
	complicationDetail: [Condition]
	partOf: [ProcedurePartOf]
	category: CodeableConcept
	report: [ProcedureReport]
	basedOn: [ProcedureBasedOn]
	complication: [CodeableConcept]
	bodySite: [CodeableConcept]
	reasonReference: [ProcedureReasonReference]
	instantiatesCanonical: [String]
	encounter: Encounter
	focalDevice: [ProcedureFocalDevice]
	asserter: ProcedureAsserter
	usedReference: [ProcedureUsedReference]
	performer: [ProcedurePerformer]
	recorder: ProcedureRecorder
}

type ProcedureFocalDevice {
    id: String! @id
	action: CodeableConcept
	manipulated: Device!
}

type ProcedurePerformer {
    id: String! @id
	function: CodeableConcept
	actor: ProcedurePerformerActor!
	onBehalfOf: Organization
}

type ProdCharacteristic {
    weight: Quantity
	externalDiameter: Quantity
	image: [Attachment]
	scoring: CodeableConcept
	height: Quantity
	nominalVolume: Quantity
	color: [String]
	id: String! @id
	depth: Quantity
	shape: String
	imprint: [String]
	width: Quantity
}

type ProductShelfLife {
    identifier: Identifier
	id: String! @id
	type: CodeableConcept!
	specialPrecautionsForStorage: [CodeableConcept]
	period: Quantity!
}

type Provenance {
    location: Location
	signature: [Signature]
	agent: [ProvenanceAgent]
	reason: [CodeableConcept]
	id: String! @id
	recorded: DateTime! @search
	entity: [ProvenanceEntity]
	target: [Resource]
	activity: CodeableConcept
	policy: [String]
}

type ProvenanceAgent {
    role: [CodeableConcept]
	onBehalfOf: ProvenanceAgentOnBehalfOf
	id: String! @id
	who: ProvenanceAgentWho!
	type: CodeableConcept
}

type ProvenanceEntity {
    id: String! @id
	role: ProvenanceEntityRole!
	what: Resource!
	agent: [ProvenanceAgent]
}

type Quantity {
    system: String
	code: String
	id: String! @id
	unit: String
	comparator: QuantityComparator
	value: Float
}

type Questionnaire {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String @search(by: [fulltext])
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	effectivePeriod: Period
	derivedFrom: [String]
	contact: [ContactDetail]
	subjectType: [String] @search(by: [exact])
	purpose: String
	code: [Coding]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	title: String @search(by: [fulltext])
	item: [QuestionnaireItem]
}

type QuestionnaireResponse {
    author: QuestionnaireResponseAuthor
	source: QuestionnaireResponseSource
	subject: Resource
	identifier: Identifier
	id: String! @id
	status: QuestionnaireResponseStatus!
	partOf: [QuestionnaireResponsePartOf]
	basedOn: [QuestionnaireResponseBasedOn]
	authored: DateTime @search
	encounter: Encounter
	questionnaire: String
	item: [QuestionnaireResponseItem]
}

type QuestionnaireResponseAnswer {
    valueDecimal: Float
	valueUri: String
	valueQuantity: Quantity
	valueString: String
	valueBoolean: Boolean
	valueDate: DateTime
	valueDateTime: DateTime
	valueInteger: Int
	id: String! @id
	valueReference: Reference
	valueTime: DateTime
	valueCoding: Coding
	valueAttachment: Attachment
	item: [QuestionnaireResponseItem]
}

type QuestionnaireResponseItem {
    linkId: String!
	text: String
	id: String! @id
	definition: String
	answer: [QuestionnaireResponseAnswer]
	item: [QuestionnaireResponseItem]
}

type QuestionnaireAnswerOption {
    valueString: String!
	initialSelected: Boolean
	valueDate: DateTime!
	valueInteger: Int!
	id: String! @id
	valueReference: Reference!
	valueTime: DateTime!
	valueCoding: Coding!
}

type QuestionnaireEnableWhen {
    question: String!
	answerCoding: Coding!
	answerString: String!
	answerTime: DateTime!
	answerDecimal: Float!
	answerReference: Reference!
	answerDate: DateTime!
	id: String! @id
	answerDateTime: DateTime!
	operator: QuestionnaireItemOperator!
	answerBoolean: Boolean!
	answerQuantity: Quantity!
	answerInteger: Int!
}

type QuestionnaireInitial {
    valueDecimal: Float!
	valueUri: String!
	valueQuantity: Quantity!
	valueString: String!
	valueBoolean: Boolean!
	valueDate: DateTime!
	valueDateTime: DateTime!
	valueInteger: Int!
	id: String! @id
	valueReference: Reference!
	valueTime: DateTime!
	valueCoding: Coding!
	valueAttachment: Attachment!
}

type QuestionnaireItem {
    linkId: String!
	readOnly: Boolean
	initial: [QuestionnaireInitial]
	prefix: String
	text: String
	answerValueSet: String
	code: [Coding]
	answerOption: [QuestionnaireAnswerOption]
	id: String! @id
	enableBehavior: EnableWhenBehavior
	repeats: Boolean
	definition: String @search(by: [exact])
	enableWhen: [QuestionnaireEnableWhen]
	type: QuestionnaireItemType!
	required: Boolean
	maxLength: Int
	item: [QuestionnaireItem]
}

type Range {
    id: String! @id
	low: Quantity
	high: Quantity
}

type Ratio {
    id: String! @id
	numerator: Quantity
	denominator: Quantity
}

type Reference {
    reference: String
	identifier: Identifier
	id: String! @id
	type: String
	display: String
}

type RelatedArtifact {
    url: String
	document: Attachment
	label: String
	citation: String
	id: String! @id
	resource: String
	type: RelatedArtifactType!
	display: String
}

type RelatedPerson {
    name: [HumanName]
	communication: [RelatedPersonCommunication]
	photo: [Attachment]
	identifier: [Identifier]
	relationship: [CodeableConcept]
	birthDate: DateTime @search
	id: String! @id
	telecom: [ContactPoint]
	address: [Address]
	period: Period
	gender: AdministrativeGender
	patient: Patient!
	active: Boolean @search
}

type RelatedPersonCommunication {
    id: String! @id
	language: CodeableConcept!
	preferred: Boolean
}

type RequestGroup {
    author: RequestGroupAuthor
	priority: RequestPriority
	subject: RequestGroupSubject
	instantiatesUri: [String] @search(by: [exact])
	identifier: [Identifier]
	intent: RequestIntent!
	authoredOn: DateTime @search
	reasonCode: [CodeableConcept]
	code: CodeableConcept
	id: String! @id
	note: [Annotation]
	status: RequestStatus!
	groupIdentifier: Identifier
	basedOn: [Resource]
	reasonReference: [RequestGroupReasonReference]
	instantiatesCanonical: [String]
	encounter: Encounter
	action: [RequestGroupAction]
	replaces: [Resource]
}

type RequestGroupAction {
    participant: [RequestGroupActionParticipant]
	priority: RequestPriority
	timingDuration: Duration
	timingPeriod: Period
	cardinalityBehavior: ActionCardinalityBehavior
	groupingBehavior: ActionGroupingBehavior
	description: String
	prefix: String
	documentation: [RelatedArtifact]
	relatedAction: [RequestGroupRelatedAction]
	timingRange: Range
	code: [CodeableConcept]
	timingAge: Age
	id: String! @id
	condition: [RequestGroupCondition]
	resource: Resource
	timingTiming: Timing
	timingDateTime: DateTime
	title: String
	type: CodeableConcept
	precheckBehavior: ActionPrecheckBehavior
	action: [RequestGroupAction]
	selectionBehavior: ActionSelectionBehavior
	requiredBehavior: ActionRequiredBehavior
	textEquivalent: String
}

type RequestGroupCondition {
    id: String! @id
	kind: ActionConditionKind!
	expression: Expression
}

type RequestGroupRelatedAction {
    offsetDuration: Duration
	actionId: String!
	offsetRange: Range
	relationship: ActionRelationshipType!
	id: String! @id
}

type ResearchDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	shortTitle: String
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	population: ResearchElementDefinition!
	effectivePeriod: Period
	endorser: [ContactDetail]
	exposureAlternative: ResearchElementDefinition
	outcome: ResearchElementDefinition
	contact: [ContactDetail]
	exposure: ResearchElementDefinition
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	comment: [String]
	library: [String]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
}

type ResearchElementDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	subtitle: String
	author: [ContactDetail]
	name: String @search(by: [fulltext])
	shortTitle: String
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	usage: String
	variableType: VariableType
	effectivePeriod: Period
	endorser: [ContactDetail]
	contact: [ContactDetail]
	purpose: String
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	comment: [String]
	library: [String]
	characteristic: [ResearchElementDefinitionCharacteristic]
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	type: ResearchElementType!
}

type ResearchElementDefinitionCharacteristic {
    usageContext: [UsageContext]
	participantEffectiveGroupMeasure: GroupMeasure
	definitionExpression: Expression!
	participantEffectiveDateTime: DateTime
	studyEffectiveGroupMeasure: GroupMeasure
	participantEffectiveTiming: Timing
	studyEffectiveDescription: String
	studyEffectiveDuration: Duration
	definitionDataRequirement: DataRequirement!
	participantEffectiveDuration: Duration
	studyEffectiveTimeFromStart: Duration
	id: String! @id
	participantEffectivePeriod: Period
	definitionCanonical: String!
	studyEffectiveDateTime: DateTime
	participantEffectiveDescription: String
	exclude: Boolean
	definitionCodeableConcept: CodeableConcept!
	studyEffectivePeriod: Period
	unitOfMeasure: CodeableConcept
	studyEffectiveTiming: Timing
	participantEffectiveTimeFromStart: Duration
}

type ResearchStudy {
    reasonStopped: CodeableConcept
	enrollment: [Group]
	location: [CodeableConcept]
	identifier: [Identifier]
	description: String
	phase: CodeableConcept
	sponsor: Organization
	site: [Location]
	contact: [ContactDetail]
	keyword: [CodeableConcept]
	arm: [ResearchStudyArm]
	objective: [ResearchStudyObjective]
	id: String! @id
	condition: [CodeableConcept]
	focus: [CodeableConcept]
	note: [Annotation]
	relatedArtifact: [RelatedArtifact]
	status: ResearchStudyStatus!
	partOf: [ResearchStudy]
	category: [CodeableConcept]
	title: String @search(by: [fulltext])
	primaryPurposeType: CodeableConcept
	protocol: [PlanDefinition]
	principalInvestigator: ResearchStudyPrincipalInvestigator
	period: Period
}

type ResearchStudyArm {
    id: String! @id
	name: String!
	type: CodeableConcept
	description: String
}

type ResearchStudyObjective {
    id: String! @id
	name: String
	type: CodeableConcept
}

type ResearchSubject {
    identifier: [Identifier]
	id: String! @id
	individual: Patient!
	status: ResearchSubjectStatus!
	consent: Consent
	assignedArm: String
	study: ResearchStudy!
	actualArm: String
	period: Period
}

type Resource {
    id: String! @id
	meta: Meta
	implicitRules: String
	language: String
}

type RiskAssessment {
    parent: Resource
	method: CodeableConcept
	subject: RiskAssessmentSubject!
	identifier: [Identifier]
	prediction: [RiskAssessmentPrediction]
	reasonCode: [CodeableConcept]
	code: CodeableConcept
	id: String! @id
	condition: Condition
	note: [Annotation]
	status: ObservationStatus!
	basedOn: Resource
	reasonReference: [RiskAssessmentReasonReference]
	basis: [Resource]
	encounter: Encounter
	performer: RiskAssessmentPerformer
	mitigation: String
}

type RiskAssessmentPrediction {
    qualitativeRisk: CodeableConcept
	whenPeriod: Period
	outcome: CodeableConcept
	whenRange: Range
	rationale: String
	id: String! @id
	relativeRisk: Float
	probabilityRange: Range
	probabilityDecimal: Float
}

type RiskEvidenceSynthesis {
    copyright: String
	jurisdiction: [CodeableConcept]
	author: [ContactDetail]
	synthesisType: CodeableConcept
	name: String @search(by: [fulltext])
	lastReviewDate: DateTime
	approvalDate: DateTime
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	population: EvidenceVariable!
	effectivePeriod: Period
	certainty: [RiskEvidenceSynthesisCertainty]
	endorser: [ContactDetail]
	outcome: EvidenceVariable!
	contact: [ContactDetail]
	exposure: EvidenceVariable
	editor: [ContactDetail]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	note: [Annotation]
	relatedArtifact: [RelatedArtifact]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	studyType: CodeableConcept
	sampleSize: RiskEvidenceSynthesisSampleSize
	topic: [CodeableConcept]
	reviewer: [ContactDetail]
	title: String @search(by: [fulltext])
	riskEstimate: RiskEvidenceSynthesisRiskEstimate
}

type RiskEvidenceSynthesisCertainty {
    id: String! @id
	rating: [CodeableConcept]
	note: [Annotation]
	certaintySubcomponent: [RiskEvidenceSynthesisCertaintySubcomponent]
}

type RiskEvidenceSynthesisCertaintySubcomponent {
    id: String! @id
	type: CodeableConcept
	rating: [CodeableConcept]
	note: [Annotation]
}

type RiskEvidenceSynthesisPrecisionEstimate {
    to: Float
	id: String! @id
	from: Float
	type: CodeableConcept
	level: Float
}

type RiskEvidenceSynthesisRiskEstimate {
    precisionEstimate: [RiskEvidenceSynthesisPrecisionEstimate]
	description: String
	numeratorCount: Int
	id: String! @id
	type: CodeableConcept
	denominatorCount: Int
	unitOfMeasure: CodeableConcept
	value: Float
}

type SampledData {
    data: String
	factor: Float
	upperLimit: Float
	id: String! @id
	lowerLimit: Float
	origin: Quantity!
	dimensions: Int!
	period: Float!
}

type Schedule {
    actor: [ScheduleActor]
	serviceType: [CodeableConcept]
	planningHorizon: Period
	serviceCategory: [CodeableConcept]
	identifier: [Identifier]
	specialty: [CodeableConcept]
	id: String! @id
	comment: String
	active: Boolean @search
}

type SearchParameter {
    xpathUsage: XPathUsageType
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String! @search(by: [fulltext])
	multipleOr: Boolean
	url: String! @search(by: [exact])
	description: String! @search(by: [fulltext])
	derivedFrom: String
	contact: [ContactDetail]
	multipleAnd: Boolean
	purpose: String
	base: [String] @search(by: [exact])
	code: String! @search(by: [exact])
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	expression: String
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	xpath: String
	target: [String] @search(by: [exact])
	modifier: [SearchModifierCode]
	comparator: [SearchComparator]
	type: SearchParamType!
	chain: [String]
	component: [SearchParameterComponent]
}

type ServiceRequest {
    supportingInfo: [Resource]
	priority: RequestPriority
	locationReference: [Location]
	subject: ServiceRequestSubject!
	performerType: CodeableConcept
	instantiatesUri: [String] @search(by: [exact])
	insurance: [ServiceRequestInsurance]
	identifier: [Identifier]
	intent: RequestIntent!
	authoredOn: DateTime @search
	locationCode: [CodeableConcept]
	requester: ServiceRequestRequester
	reasonCode: [CodeableConcept]
	code: CodeableConcept
	doNotPerform: Boolean
	id: String! @id
	note: [Annotation]
	status: RequestStatus!
	patientInstruction: String
	category: [CodeableConcept]
	basedOn: [ServiceRequestBasedOn]
	bodySite: [CodeableConcept]
	specimen: [Specimen]
	requisition: Identifier
	reasonReference: [ServiceRequestReasonReference]
	instantiatesCanonical: [String]
	relevantHistory: [Provenance]
	encounter: Encounter
	orderDetail: [CodeableConcept]
	replaces: [ServiceRequest]
	performer: [ServiceRequestPerformer]
}

type Signature {
    onBehalfOf: Reference
	data: String
	id: String! @id
	who: Reference!
	targetFormat: String
	type: [Coding]
	when: DateTime!
	sigFormat: String
}

type Slot {
    overbooked: Boolean
	serviceType: [CodeableConcept]
	serviceCategory: [CodeableConcept]
	appointmentType: CodeableConcept
	identifier: [Identifier]
	specialty: [CodeableConcept]
	id: String! @id
	status: SlotStatus!
	comment: String
	schedule: Schedule!
	end: DateTime!
	start: DateTime! @search
}

type Specimen {
    parent: [Specimen]
	request: [ServiceRequest]
	subject: SpecimenSubject
	collection: SpecimenCollection
	identifier: [Identifier]
	container: [SpecimenContainer]
	processing: [SpecimenProcessing]
	id: String! @id
	condition: [CodeableConcept]
	receivedTime: DateTime
	note: [Annotation]
	status: SpecimenStatus
	accessionIdentifier: Identifier
	type: CodeableConcept
}

type SpecimenDefinition {
    patientPreparation: [CodeableConcept]
	collection: [CodeableConcept]
	identifier: Identifier
	timeAspect: String
	id: String! @id
	typeTested: [SpecimenDefinitionTypeTested]
	typeCollected: CodeableConcept
}

type SpecimenDefinitionAdditive {
    id: String! @id
	additiveCodeableConcept: CodeableConcept!
	additiveReference: Reference!
}

type SpecimenDefinitionContainer {
    description: String
	additive: [SpecimenDefinitionAdditive]
	minimumVolumeQuantity: Quantity
	id: String! @id
	material: CodeableConcept
	type: CodeableConcept
	minimumVolumeString: String
	preparation: String
	cap: CodeableConcept
	capacity: Quantity
}

type SpecimenDefinitionHandling {
    temperatureQualifier: CodeableConcept
	temperatureRange: Range
	instruction: String
	id: String! @id
	maxDuration: Duration
}

type SpecimenDefinitionTypeTested {
    preference: SpecimenContainedPreference!
	handling: [SpecimenDefinitionHandling]
	container: SpecimenDefinitionContainer
	retentionTime: Duration
	requirement: String
	id: String! @id
	rejectionCriterion: [CodeableConcept]
	type: CodeableConcept
	isDerived: Boolean
}

type SpecimenCollection {
    duration: Duration
	method: CodeableConcept
	collector: SpecimenCollectionCollector
	quantity: Quantity
	collectedDateTime: DateTime
	collectedPeriod: Period
	id: String! @id
	fastingStatusDuration: Duration
	bodySite: CodeableConcept
	fastingStatusCodeableConcept: CodeableConcept
}

type SpecimenContainer {
    additiveCodeableConcept: CodeableConcept
	identifier: [Identifier]
	description: String
	specimenQuantity: Quantity
	additiveReference: Reference
	id: String! @id
	type: CodeableConcept
	capacity: Quantity
}

type SpecimenProcessing {
    timeDateTime: DateTime
	description: String
	additive: [Substance]
	procedure: CodeableConcept
	id: String! @id
	timePeriod: Period
}

type StructureDefinition {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean @search
	name: String! @search(by: [fulltext])
	identifier: [Identifier]
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	context: [StructureDefinitionContext]
	abstract: Boolean! @search
	fhirVersion: FHIRVersion
	baseDefinition: String
	mapping: [StructureDefinitionMapping]
	contact: [ContactDetail]
	keyword: [Coding]
	purpose: String
	differential: StructureDefinitionDifferential
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	snapshot: StructureDefinitionSnapshot
	date: DateTime @search
	contextInvariant: [String]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	derivation: TypeDerivationRule
	kind: StructureDefinitionKind!
	title: String @search(by: [fulltext])
	type: String! @search(by: [exact])
}

type StructureDefinitionContext {
    id: String! @id
	type: ExtensionContextType!
	expression: String!
}

type StructureDefinitionDifferential {
    id: String! @id
	element: [ElementDefinition]
}

type StructureDefinitionSnapshot {
    id: String! @id
	element: [ElementDefinition]
}

type StructureMap {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String! @search(by: [fulltext])
	identifier: [Identifier]
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	purpose: String
	version: String @search(by: [exact])
	useContext: [UsageContext]
	import: [String]
	id: String! @id
	structure: [StructureMapStructure]
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	title: String @search(by: [fulltext])
	group: [StructureMapGroup]
}

type StructureMapGroup {
    typeMode: StructureMapGroupTypeMode!
	name: String!
	documentation: String
	rule: [StructureMapRule]
	id: String! @id
	extends: String
	input: [StructureMapInput]
}

type StructureMapInput {
    name: String!
	documentation: String
	id: String! @id
	mode: StructureMapInputMode!
	type: String
}

type StructureMapRule {
    name: String!
	source: [StructureMapSource]
	documentation: String
	rule: [StructureMapRule]
	id: String! @id
	dependent: [StructureMapDependent]
	target: [StructureMapTarget]
}

type StructureMapSource {
    defaultValueTiming: Timing
	defaultValueUuid: String
	defaultValueInteger: Int
	defaultValueUnsignedInt: Int
	defaultValueCanonical: String
	defaultValueDistance: Distance
	defaultValueAge: Age
	defaultValueUri: String
	defaultValueExpression: Expression
	defaultValueContactDetail: ContactDetail
	defaultValueSignature: Signature
	defaultValuePositiveInt: Int
	context: String!
	defaultValueRatio: Ratio
	logMessage: String
	defaultValueUsageContext: UsageContext
	min: Int
	defaultValueQuantity: Quantity
	defaultValueDuration: Duration
	defaultValueMarkdown: String
	defaultValueDate: DateTime
	defaultValueCount: Count
	element: String
	defaultValuePeriod: Period
	defaultValueContactPoint: ContactPoint
	defaultValueCoding: Coding
	defaultValueCode: String
	defaultValueMoney: Money
	listMode: StructureMapSourceListMode
	defaultValueHumanName: HumanName
	id: String! @id
	defaultValueTriggerDefinition: TriggerDefinition
	condition: String
	defaultValueAddress: Address
	max: String
	check: String
	defaultValueOid: String
	defaultValueDateTime: DateTime
	defaultValueMeta: Meta
	defaultValueRelatedArtifact: RelatedArtifact
	defaultValueBoolean: Boolean
	variable: String
	defaultValueIdentifier: Identifier
	defaultValueContributor: Contributor
	defaultValueUrl: String
	defaultValueTime: DateTime
	defaultValueDataRequirement: DataRequirement
	defaultValueInstant: DateTime
	defaultValueDecimal: Float
	defaultValueId: String
	defaultValueAnnotation: Annotation
	defaultValueCodeableConcept: CodeableConcept
	type: String
	defaultValueString: String
	defaultValueReference: Reference
	defaultValueBase64Binary: String
	defaultValueAttachment: Attachment
	defaultValueRange: Range
	defaultValueSampledData: SampledData
	defaultValueDosage: Dosage
	defaultValueParameterDefinition: ParameterDefinition
}

type StructureMapStructure {
    url: String!
	documentation: String
	alias: String
	id: String! @id
	mode: StructureMapModelMode!
}

type StructureMapTarget {
    parameter: [StructureMapParameter]
	listRuleId: String
	context: String
	contextType: StructureMapContextType
	element: String
	listMode: [StructureMapTargetListMode]
	id: String! @id
	variable: String
	transform: StructureMapTransform
}

type Subscription_ {
    channel: SubscriptionChannel!
	criteria: String!
	contact: [ContactPoint]
	reason: String!
	id: String! @id
	error: String
	status: SubscriptionStatus!
	end: DateTime
}

type SubscriptionChannel {
    payload: String @search(by: [exact])
	id: String! @id
	endpoint: String @search(by: [exact])
	header: [String]
	type: SubscriptionChannelType!
}

type Substance {
    identifier: [Identifier]
	description: String
	ingredient: [SubstanceIngredient]
	instance: [SubstanceInstance]
	code: CodeableConcept!
	id: String! @id
	status: FHIRSubstanceStatus
	category: [CodeableConcept]
}

type SubstanceAmount {
    amountRange: Range
	referenceRange: SubstanceAmountReferenceRange
	amountString: String
	id: String! @id
	amountText: String
	amountType: CodeableConcept
	amountQuantity: Quantity
}

type SubstanceAmountReferenceRange {
    id: String! @id
	lowLimit: Quantity
	highLimit: Quantity
}

type SubstanceNucleicAcid {
    sequenceType: CodeableConcept
	areaOfHybridisation: String
	oligoNucleotideType: CodeableConcept
	id: String! @id
	subunit: [SubstanceNucleicAcidSubunit]
	numberOfSubunits: Int
}

type SubstanceNucleicAcidLinkage {
    residueSite: String
	name: String
	identifier: Identifier
	id: String! @id
	connectivity: String
}

type SubstanceNucleicAcidSubunit {
    threePrime: CodeableConcept
	sugar: [SubstanceNucleicAcidSugar]
	linkage: [SubstanceNucleicAcidLinkage]
	sequenceAttachment: Attachment
	id: String! @id
	sequence: String
	subunit: Int
	fivePrime: CodeableConcept
	length: Int
}

type SubstanceNucleicAcidSugar {
    id: String! @id
	identifier: Identifier
	name: String
	residueSite: String
}

type SubstancePolymer {
    copolymerConnectivity: [CodeableConcept]
	modification: [String]
	monomerSet: [SubstancePolymerMonomerSet]
	id: String! @id
	class: CodeableConcept
	repeat: [SubstancePolymerRepeat]
	geometry: CodeableConcept
}

type SubstancePolymerDegreeOfPolymerisation {
    id: String! @id
	degree: CodeableConcept
	amount: SubstanceAmount
}

type SubstancePolymerMonomerSet {
    id: String! @id
	ratioType: CodeableConcept
	startingMaterial: [SubstancePolymerStartingMaterial]
}

type SubstancePolymerRepeat {
    repeatUnit: [SubstancePolymerRepeatUnit]
	id: String! @id
	repeatUnitAmountType: CodeableConcept
	numberOfUnits: Int
	averageMolecularFormula: String
}

type SubstancePolymerRepeatUnit {
    orientationOfPolymerisation: CodeableConcept
	amount: SubstanceAmount
	repeatUnit: String
	id: String! @id
	structuralRepresentation: [SubstancePolymerStructuralRepresentation]
	degreeOfPolymerisation: [SubstancePolymerDegreeOfPolymerisation]
}

type SubstancePolymerStartingMaterial {
    isDefining: Boolean
	amount: SubstanceAmount
	id: String! @id
	material: CodeableConcept
	type: CodeableConcept
}

type SubstancePolymerStructuralRepresentation {
    id: String! @id
	type: CodeableConcept
	representation: String
	attachment: Attachment
}

type SubstanceProtein {
    sequenceType: CodeableConcept
	disulfideLinkage: [String]
	id: String! @id
	subunit: [SubstanceProteinSubunit]
	numberOfSubunits: Int
}

type SubstanceProteinSubunit {
    cTerminalModificationId: Identifier
	nTerminalModification: String
	nTerminalModificationId: Identifier
	sequenceAttachment: Attachment
	id: String! @id
	sequence: String
	subunit: Int
	cTerminalModification: String
	length: Int
}

type SubstanceReferenceInformation {
    geneElement: [SubstanceReferenceInformationGeneElement]
	id: String! @id
	comment: String
	target: [SubstanceReferenceInformationTarget]
	classification: [SubstanceReferenceInformationClassification]
	gene: [SubstanceReferenceInformationGene]
}

type SubstanceReferenceInformationClassification {
    source: [DocumentReference]
	subtype: [CodeableConcept]
	domain: CodeableConcept
	id: String! @id
	classification: CodeableConcept
}

type SubstanceReferenceInformationGene {
    id: String! @id
	geneSequenceOrigin: CodeableConcept
	gene: CodeableConcept
	source: [DocumentReference]
}

type SubstanceReferenceInformationGeneElement {
    id: String! @id
	type: CodeableConcept
	element: Identifier
	source: [DocumentReference]
}

type SubstanceReferenceInformationTarget {
    source: [DocumentReference]
	interaction: CodeableConcept
	amountRange: Range
	amountString: String
	organismType: CodeableConcept
	id: String! @id
	target: Identifier
	organism: CodeableConcept
	type: CodeableConcept
	amountType: CodeableConcept
	amountQuantity: Quantity
}

type SubstanceSourceMaterial {
    developmentStage: CodeableConcept
	sourceMaterialState: CodeableConcept
	fractionDescription: [SubstanceSourceMaterialFractionDescription]
	parentSubstanceName: [String]
	geographicalLocation: [String]
	parentSubstanceId: [Identifier]
	countryOfOrigin: [CodeableConcept]
	id: String! @id
	organism: SubstanceSourceMaterialOrganism
	organismId: Identifier
	organismName: String
	sourceMaterialType: CodeableConcept
	partDescription: [SubstanceSourceMaterialPartDescription]
	sourceMaterialClass: CodeableConcept
}

type SubstanceSourceMaterialAuthor {
    id: String! @id
	authorType: CodeableConcept
	authorDescription: String
}

type SubstanceSourceMaterialFractionDescription {
    id: String! @id
	fraction: String
	materialType: CodeableConcept
}

type SubstanceSourceMaterialHybrid {
    paternalOrganismId: String
	paternalOrganismName: String
	hybridType: CodeableConcept
	maternalOrganismName: String
	id: String! @id
	maternalOrganismId: String
}

type SubstanceSourceMaterialOrganism {
    species: CodeableConcept
	organismGeneral: SubstanceSourceMaterialOrganismGeneral
	author: [SubstanceSourceMaterialAuthor]
	intraspecificType: CodeableConcept
	intraspecificDescription: String
	id: String! @id
	genus: CodeableConcept
	hybrid: SubstanceSourceMaterialHybrid
	family: CodeableConcept
}

type SubstanceSourceMaterialOrganismGeneral {
    phylum: CodeableConcept
	kingdom: CodeableConcept
	id: String! @id
	order: CodeableConcept
	class: CodeableConcept
}

type SubstanceSourceMaterialPartDescription {
    id: String! @id
	part: CodeableConcept
	partLocation: CodeableConcept
}

type SubstanceSpecification {
    name: [SubstanceSpecificationName]
	source: [DocumentReference]
	sourceMaterial: SubstanceSourceMaterial
	identifier: Identifier
	description: String
	domain: CodeableConcept
	protein: SubstanceProtein
	polymer: SubstancePolymer
	code: [SubstanceSpecificationCode]
	referenceInformation: SubstanceReferenceInformation
	relationship: [SubstanceSpecificationRelationship]
	id: String! @id
	structure: SubstanceSpecificationStructure
	status: CodeableConcept
	comment: String
	molecularWeight: [SubstanceSpecificationMolecularWeight]
	property: [SubstanceSpecificationProperty]
	type: CodeableConcept
	nucleicAcid: SubstanceNucleicAcid
	moiety: [SubstanceSpecificationMoiety]
}

type SubstanceSpecificationCode {
    source: [DocumentReference]
	statusDate: DateTime
	code: CodeableConcept
	id: String! @id
	status: CodeableConcept
	comment: String
}

type SubstanceSpecificationIsotope {
    halfLife: Quantity
	name: CodeableConcept
	identifier: Identifier
	id: String! @id
	molecularWeight: SubstanceSpecificationMolecularWeight
	substitution: CodeableConcept
}

type SubstanceSpecificationMoiety {
    name: String
	molecularFormula: String
	identifier: Identifier
	role: CodeableConcept
	amountString: String
	id: String! @id
	stereochemistry: CodeableConcept
	opticalActivity: CodeableConcept
	amountQuantity: Quantity
}

type SubstanceSpecificationMolecularWeight {
    id: String! @id
	method: CodeableConcept
	type: CodeableConcept
	amount: Quantity
}

type SubstanceSpecificationName {
    jurisdiction: [CodeableConcept]
	name: String!
	source: [DocumentReference]
	preferred: Boolean
	domain: [CodeableConcept]
	synonym: [SubstanceSpecificationName]
	id: String! @id
	language: [CodeableConcept]
	official: [SubstanceSpecificationOfficial]
	status: CodeableConcept
	type: CodeableConcept
	translation: [SubstanceSpecificationName]
}

type SubstanceSpecificationOfficial {
    id: String! @id
	authority: CodeableConcept
	status: CodeableConcept
	date: DateTime
}

type SubstanceSpecificationProperty {
    amountString: String
	definingSubstanceReference: SubstanceSpecificationPropertyDefiningSubstanceReference
	code: CodeableConcept
	id: String! @id
	category: CodeableConcept
	parameters: String
	amountQuantity: Quantity
	definingSubstanceCodeableConcept: CodeableConcept
}

type SubstanceSpecificationRelationship {
    substanceCodeableConcept: CodeableConcept
	source: [DocumentReference]
	amountRange: Range
	substanceReference: SubstanceSpecification
	amountString: String
	isDefining: Boolean
	amountRatio: Ratio
	relationship: CodeableConcept
	id: String! @id
	amountRatioLowLimit: Ratio
	amountType: CodeableConcept
	amountQuantity: Quantity
}

type SubstanceSpecificationRepresentation {
    id: String! @id
	type: CodeableConcept
	representation: String
	attachment: Attachment
}

type SubstanceSpecificationStructure {
    source: [DocumentReference]
	molecularFormula: String
	molecularFormulaByMoiety: String
	isotope: [SubstanceSpecificationIsotope]
	id: String! @id
	stereochemistry: CodeableConcept
	opticalActivity: CodeableConcept
	molecularWeight: SubstanceSpecificationMolecularWeight
	representation: [SubstanceSpecificationRepresentation]
}

type SubstanceIngredient {
    id: String! @id
	quantity: Ratio
	substanceCodeableConcept: CodeableConcept!
	substanceReference: Reference!
}

type SubstanceInstance {
    id: String! @id
	identifier: Identifier
	expiry: DateTime @search
	quantity: Quantity
}

type SupplyDelivery {
    identifier: [Identifier]
	receiver: [SupplyDeliveryReceiver]
	supplier: SupplyDeliverySupplier
	id: String! @id
	status: SupplyDeliveryStatus
	partOf: [SupplyDeliveryPartOf]
	suppliedItem: SupplyDeliverySuppliedItem
	basedOn: [SupplyRequest]
	type: CodeableConcept
	destination: Location
	patient: Patient
}

type SupplyDeliverySuppliedItem {
    id: String! @id
	quantity: Quantity
	itemCodeableConcept: CodeableConcept
	itemReference: Reference
}

type SupplyRequest {
    deliverTo: SupplyRequestDeliverTo
	parameter: [SupplyRequestParameter]
	quantity: Quantity!
	priority: RequestPriority
	identifier: [Identifier]
	authoredOn: DateTime @search
	requester: SupplyRequestRequester
	supplier: [SupplyRequestSupplier]
	reasonCode: [CodeableConcept]
	id: String! @id
	status: SupplyRequestStatus
	deliverFrom: SupplyRequestDeliverFrom
	category: CodeableConcept
	reasonReference: [SupplyRequestReasonReference]
}

type SupplyRequestParameter {
    valueQuantity: Quantity
	valueBoolean: Boolean
	code: CodeableConcept
	valueRange: Range
	id: String! @id
	valueCodeableConcept: CodeableConcept
}

type Task {
    for: Resource
	priority: RequestPriority
	statusReason: CodeableConcept
	location: Location
	performerType: [CodeableConcept]
	instantiatesUri: String
	insurance: [TaskInsurance]
	businessStatus: CodeableConcept
	identifier: [Identifier]
	intent: TaskIntent!
	lastModified: DateTime @search
	authoredOn: DateTime @search
	description: String
	requester: TaskRequester
	reasonCode: CodeableConcept
	code: CodeableConcept
	id: String! @id
	restriction: TaskRestriction
	focus: Resource
	note: [Annotation]
	status: TaskStatus!
	partOf: [Task]
	groupIdentifier: Identifier
	basedOn: [Resource]
	owner: TaskOwner
	executionPeriod: Period
	output: [TaskOutput]
	reasonReference: Resource
	instantiatesCanonical: String
	relevantHistory: [Provenance]
	encounter: Encounter
	input: [TaskInput]
}

type TaskInput {
    valueDecimal: Float!
	valueHumanName: HumanName!
	valueCode: String!
	valueDosage: Dosage!
	valueMarkdown: String!
	valueUri: String!
	valueContactDetail: ContactDetail!
	valueAge: Age!
	valueUsageContext: UsageContext!
	valueQuantity: Quantity!
	valueDataRequirement: DataRequirement!
	valueCount: Count!
	valueString: String!
	valueBoolean: Boolean!
	valueIdentifier: Identifier!
	valueDistance: Distance!
	valueMoney: Money!
	valueDate: DateTime!
	valueRange: Range!
	valueDateTime: DateTime!
	valueId: String!
	valueUnsignedInt: Int!
	valueMeta: Meta!
	valueInteger: Int!
	id: String! @id
	valuePositiveInt: Int!
	valueParameterDefinition: ParameterDefinition!
	valuePeriod: Period!
	valueReference: Reference!
	valueContactPoint: ContactPoint!
	valueTime: DateTime!
	valueTriggerDefinition: TriggerDefinition!
	valueUuid: String!
	valueRelatedArtifact: RelatedArtifact!
	valueInstant: DateTime!
	valueExpression: Expression!
	valueBase64Binary: String!
	valueOid: String!
	valueSampledData: SampledData!
	valueContributor: Contributor!
	valueCoding: Coding!
	valueUrl: String!
	valueRatio: Ratio!
	valueDuration: Duration!
	type: CodeableConcept!
	valueCanonical: String!
	valueCodeableConcept: CodeableConcept!
	valueAnnotation: Annotation!
	valueAttachment: Attachment!
	valueAddress: Address!
	valueTiming: Timing!
	valueSignature: Signature!
}

type TaskOutput {
    valueDecimal: Float!
	valueHumanName: HumanName!
	valueCode: String!
	valueDosage: Dosage!
	valueMarkdown: String!
	valueUri: String!
	valueContactDetail: ContactDetail!
	valueAge: Age!
	valueUsageContext: UsageContext!
	valueQuantity: Quantity!
	valueDataRequirement: DataRequirement!
	valueCount: Count!
	valueString: String!
	valueBoolean: Boolean!
	valueIdentifier: Identifier!
	valueDistance: Distance!
	valueMoney: Money!
	valueDate: DateTime!
	valueRange: Range!
	valueDateTime: DateTime!
	valueId: String!
	valueUnsignedInt: Int!
	valueMeta: Meta!
	valueInteger: Int!
	id: String! @id
	valuePositiveInt: Int!
	valueParameterDefinition: ParameterDefinition!
	valuePeriod: Period!
	valueReference: Reference!
	valueContactPoint: ContactPoint!
	valueTime: DateTime!
	valueTriggerDefinition: TriggerDefinition!
	valueUuid: String!
	valueRelatedArtifact: RelatedArtifact!
	valueInstant: DateTime!
	valueExpression: Expression!
	valueBase64Binary: String!
	valueOid: String!
	valueSampledData: SampledData!
	valueContributor: Contributor!
	valueCoding: Coding!
	valueUrl: String!
	valueRatio: Ratio!
	valueDuration: Duration!
	type: CodeableConcept!
	valueCanonical: String!
	valueCodeableConcept: CodeableConcept!
	valueAnnotation: Annotation!
	valueAttachment: Attachment!
	valueAddress: Address!
	valueTiming: Timing!
	valueSignature: Signature!
}

type TaskRestriction {
    id: String! @id
	repetitions: Int
	period: Period
	recipient: [TaskRestrictionRecipient]
}

type TerminologyCapabilities {
    copyright: String
	jurisdiction: [CodeableConcept]
	validateCode: TerminologyCapabilitiesValidateCode
	experimental: Boolean
	name: String @search(by: [fulltext])
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	expansion: TerminologyCapabilitiesExpansion
	codeSystem: [TerminologyCapabilitiesCodeSystem]
	lockedDate: Boolean
	contact: [ContactDetail]
	purpose: String
	closure: TerminologyCapabilitiesClosure
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	implementation: TerminologyCapabilitiesImplementation
	date: DateTime! @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	software: TerminologyCapabilitiesSoftware
	codeSearch: CodeSearchSupport
	kind: CapabilityStatementKind!
	title: String @search(by: [fulltext])
	translation: TerminologyCapabilitiesTranslation
}

type TerminologyCapabilitiesCodeSystem {
    id: String! @id
	uri: String
	version: [TerminologyCapabilitiesVersion]
	subsumption: Boolean
}

type TerminologyCapabilitiesExpansion {
    hierarchical: Boolean
	parameter: [TerminologyCapabilitiesParameter]
	incomplete: Boolean
	textFilter: String
	paging: Boolean
	id: String! @id
}

type TerminologyCapabilitiesVersion {
    compositional: Boolean
	code: String
	filter: [TerminologyCapabilitiesFilter_]
	id: String! @id
	language: [String]
	property: [String]
	isDefault: Boolean
}

type TestReport {
    teardown: TestReportTeardown
	participant: [TestReportParticipant]
	test: [TestReportTest]
	name: String
	identifier: Identifier
	result: TestReportResult!
	score: Float
	tester: String @search(by: [fulltext])
	issued: DateTime @search
	id: String! @id
	status: TestReportStatus!
	testScript: TestScript!
	setup: TestReportSetup
}

type TestReportAction {
    id: String! @id
	operation: TestReportOperation
	assert: TestReportAssert
}

type TestReportAction1 {
    id: String! @id
	operation: TestReportOperation
	assert: TestReportAssert
}

type TestReportAction2 {
    id: String! @id
	operation: TestReportOperation!
}

type TestReportAssert {
    id: String! @id
	result: TestReportActionResult!
	message: String
	detail: String
}

type TestReportOperation {
    id: String! @id
	result: TestReportActionResult!
	message: String
	detail: String
}

type TestReportParticipant {
    id: String! @id
	type: TestReportParticipantType!
	uri: String! @search(by: [exact])
	display: String
}

type TestReportSetup {
    id: String! @id
	action: [TestReportAction]
}

type TestReportTeardown {
    id: String! @id
	action: [TestReportAction2]
}

type TestReportTest {
    id: String! @id
	name: String
	description: String
	action: [TestReportAction1]
}

type TestScript {
    teardown: TestScriptTeardown
	copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	test: [TestScriptTest]
	name: String! @search(by: [fulltext])
	identifier: Identifier
	url: String! @search(by: [exact])
	description: String @search(by: [fulltext])
	contact: [ContactDetail]
	purpose: String
	fixture: [TestScriptFixture]
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	profile: [Resource]
	date: DateTime @search
	origin: [TestScriptOrigin]
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	variable: [TestScriptVariable]
	metadata: TestScriptMetadata
	title: String @search(by: [fulltext])
	destination: [TestScriptDestination]
	setup: TestScriptSetup
}

type TestScriptAction {
    id: String! @id
	operation: TestScriptOperation
	assert: TestScriptAssert
}

type TestScriptAction1 {
    id: String! @id
	operation: TestScriptOperation
	assert: TestScriptAssert
}

type TestScriptAction2 {
    id: String! @id
	operation: TestScriptOperation!
}

type TestScriptAssert {
    responseCode: String
	path: String
	minimumId: String
	description: String
	compareToSourceId: String
	label: String
	requestURL: String
	direction: AssertionDirectionType
	warningOnly: Boolean!
	navigationLinks: Boolean
	response: AssertionResponseTypes
	id: String! @id
	contentType: String
	expression: String
	resource: String
	compareToSourcePath: String
	requestMethod: TestScriptRequestMethodCode
	operator: AssertionOperatorType
	compareToSourceExpression: String
	headerField: String
	value: String
	validateProfileId: String
	sourceId: String
}

type TestScriptDestination {
    id: String! @id
	index: Int!
	profile: Coding!
}

type TestScriptFixture {
    id: String! @id
	autocreate: Boolean!
	autodelete: Boolean!
	resource: Resource
}

type TestScriptMetadata {
    id: String! @id
	link: [TestScriptLink]
	capability: [TestScriptCapability]
}

type TestScriptOperation {
    method: TestScriptRequestMethodCode
	accept: String
	url: String
	description: String
	params: String
	label: String
	requestHeader: [TestScriptRequestHeader]
	targetId: String
	responseId: String
	id: String! @id
	contentType: String
	resource: String
	encodeRequestUrl: Boolean!
	origin: Int
	requestId: String
	type: Coding
	destination: Int
	sourceId: String
}

type TestScriptOrigin {
    id: String! @id
	index: Int!
	profile: Coding!
}

type TestScriptSetup {
    id: String! @id
	action: [TestScriptAction]
}

type TestScriptTeardown {
    id: String! @id
	action: [TestScriptAction2]
}

type TestScriptTest {
    id: String! @id
	name: String
	description: String
	action: [TestScriptAction1]
}

type Timing {
    id: String! @id
	event: [DateTime] @search
	repeat: TimingRepeat
	code: CodeableConcept
}

type TimingRepeat {
    duration: Float
	durationMax: Float
	count: Int
	timeOfDay: [DateTime]
	boundsRange: Range
	dayOfWeek: [String]
	boundsDuration: Duration
	periodMax: Float
	id: String! @id
	offset: Int
	countMax: Int
	durationUnit: UnitsOfTime
	frequencyMax: Int
	frequency: Int
	periodUnit: UnitsOfTime
	when: [EventTiming]
	boundsPeriod: Period
	period: Float
}

type TriggerDefinition {
    name: String
	data: [DataRequirement]
	timingReference: Reference
	id: String! @id
	condition: Expression
	timingTiming: Timing
	timingDateTime: DateTime
	timingDate: DateTime
	type: TriggerType!
}

type UsageContext {
    valueQuantity: Quantity!
	code: Coding!
	valueRange: Range!
	id: String! @id
	valueReference: Reference!
	valueCodeableConcept: CodeableConcept!
}

type ValueSet {
    copyright: String
	jurisdiction: [CodeableConcept]
	experimental: Boolean
	name: String @search(by: [fulltext])
	compose: ValueSetCompose
	identifier: [Identifier]
	url: String @search(by: [exact])
	description: String @search(by: [fulltext])
	expansion: ValueSetExpansion
	contact: [ContactDetail]
	purpose: String
	immutable: Boolean
	version: String @search(by: [exact])
	useContext: [UsageContext]
	id: String! @id
	date: DateTime @search
	status: PublicationStatus!
	publisher: String @search(by: [fulltext])
	title: String @search(by: [fulltext])
}

type ValueSetCompose {
    lockedDate: DateTime
	id: String! @id
	include: [ValueSetInclude]
	inactive: Boolean
	exclude: [ValueSetInclude]
}

type ValueSetConcept {
    id: String! @id
	code: String!
	display: String
	designation: [ValueSetDesignation]
}

type ValueSetContains {
    system: String
	designation: [ValueSetDesignation]
	abstract: Boolean
	code: String
	version: String
	id: String! @id
	inactive: Boolean
	contains: [ValueSetContains]
	display: String
}

type ValueSetDesignation {
    id: String! @id
	language: String
	use: Coding
	value: String!
}

type ValueSetExpansion {
    parameter: [ValueSetParameter]
	timestamp: DateTime!
	identifier: String @search(by: [exact])
	total: Int
	id: String! @id
	offset: Int
	contains: [ValueSetContains]
}

type ValueSetFilter_ {
    id: String! @id
	property: String!
	op: FilterOperator!
	value: String!
}

type ValueSetInclude {
    valueSet: [String]
	system: String
	filter: [ValueSetFilter_]
	version: String
	id: String! @id
	concept: [ValueSetConcept]
}

type VerificationResult {
    failureAction: CodeableConcept
	validationProcess: [CodeableConcept]
	statusDate: DateTime
	attestation: VerificationResultAttestation
	validator: [VerificationResultValidator]
	targetLocation: [String]
	primarySource: [VerificationResultPrimarySource]
	id: String! @id
	need: CodeableConcept
	status: Status!
	validationType: CodeableConcept
	target: [Resource]
	frequency: Timing
	lastPerformed: DateTime
	nextScheduled: DateTime
}

type VerificationResultAttestation {
    sourceIdentityCertificate: String
	onBehalfOf: VerificationResultAttestationOnBehalfOf
	proxyIdentityCertificate: String
	proxySignature: Signature
	id: String! @id
	date: DateTime
	who: VerificationResultAttestationWho
	communicationMethod: CodeableConcept
	sourceSignature: Signature
}

type VerificationResultPrimarySource {
    validationDate: DateTime
	id: String! @id
	pushTypeAvailable: [CodeableConcept]
	who: VerificationResultPrimarySourceWho
	communicationMethod: [CodeableConcept]
	type: [CodeableConcept]
	validationStatus: CodeableConcept
	canPushUpdates: CodeableConcept
}

type VerificationResultValidator {
    id: String! @id
	organization: Organization!
	identityCertificate: String
	attestationSignature: Signature
}

type VisionPrescription {
    prescriber: VisionPrescriptionPrescriber!
	identifier: [Identifier]
	dateWritten: DateTime! @search
	id: String! @id
	status: FinancialResourceStatusCodes!
	encounter: Encounter
	lensSpecification: [VisionPrescriptionLensSpecification]
	created: DateTime!
	patient: Patient!
}

type VisionPrescriptionLensSpecification {
    eye: VisionEyes!
	duration: Quantity
	sphere: Float
	cylinder: Float
	color: String
	brand: String
	prism: [VisionPrescriptionPrism]
	id: String! @id
	note: [Annotation]
	diameter: Float
	backCurve: Float
	power: Float
	axis: Int
	add: Float
	product: CodeableConcept!
}

type VisionPrescriptionPrism {
    id: String! @id
	amount: Float!
	base: VisionBase!
}

#----------------------------------*** Schema Definition Completed ***----------------------------------

